<!DOCTYPE html>

<html lang="">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>锐哥的个人空间 | C++学习笔记（15）类继承</title>

    
    <meta name="description" content="">
    <meta name="keywords" content="">
    <meta name="author" content="锐哥">

    <meta name="color-scheme" content="light dark">

    
    
<link rel="stylesheet" href="/styles/index.css">

    
    <link rel="shortcut icon" href="/imgs/logo.png">

    
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css">
    
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/styles/base16/solarized-light.css">
    

    
<meta name="generator" content="Hexo 7.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body id="delicate-app">
    <main>
        <div class="container">
            <section class="page-top-badge flex-between w100">
                <div>
                    <a href="/">
                        <span title="github"><i class="fa fa-home" aria-hidden="true"></i></span>
                    </a>
                </div>
                <!-- <div>
                    
                </div> -->
            </section>
            <aside class="toc-container">
    <!-- sticky toc -->
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">继承的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">继承方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">继承的对象模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0%E5%9F%BA%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">如何构造基类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E9%81%AE%E8%94%BD%E4%B8%8E%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">5.</span> <span class="toc-text">名字遮蔽与类作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E6%AE%8A%E5%85%B3%E7%B3%BB"><span class="toc-number">6.</span> <span class="toc-text">继承的特殊关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">7.</span> <span class="toc-text">多继承与虚继承</span></a></li></ol>
</aside>

<article class="markdown-container">
    <section>
        <h1>
            <span>
                C++学习笔记（15）类继承
            </span>
        
            <div class="post-info">
                <span></span>
                <span>
                    12k字 • 
                    24分钟
                </span>
            </div>
        </h1>
    </section>

    <section class="article">
        <h2 id="继承的基本概念">继承的基本概念</h2>
<p>继承可以理解为一个类从另一个类获取成员变量和成员函数的过程。<br>
语法：<br>
class 派生类名:［继承方式］基类名<br>
{<br>
派生类新增加的成员<br>
};<br>
被继承的类称为基类或父类，继承的类称为派生类或子类。<br>
继承和派生是一个概念，只是站的角度不同。<br>
派生类除了拥有基类的成员，还可以定义新的成员，以增强其功能。<br>
使用继承的场景：</p>
<ol>
<li>如果新创建的类与现有的类相似，只是多出若干成员变量或成员函数时，可以使用继承。</li>
<li>当需要创建多个类时，如果它们拥有很多相似的成员变量或成员函数，可以将这些类共同的成员提取出来，定义为基类，然后从基类继承。<br>
示例：<br>
#include <iostream>         // 包含头文件。<br>
using namespace std;        // 指定缺省的命名空间。</iostream></li>
</ol>
<p>class CAllComers          // 海选报名者类<br>
{<br>
public:<br>
string    m_name;    // 姓名<br>
string    m_tel;         // 联系电话</p>
<pre><code>// 构造函数。
CAllComers() { m_name = "某女"; m_tel = "不详"; }
// 报名时需要唱一首歌。
void sing() { cout &lt;&lt; "我是一只小小鸟。\n"; }
// 设置姓名。
void setname(const string&amp; name) { m_name = name; }
// 设置电话号码。
void settel(const string&amp; tel) { m_tel = tel; }
</code></pre>
<p>};</p>
<p>class CGirl :public CAllComers        // 超女类<br>
{<br>
public:<br>
int m_bh;          // 编号。<br>
CGirl() { m_bh = 8;  }<br>
void show() { cout &lt;&lt; “编号：” &lt;&lt; m_bh &lt;&lt; “，姓名：” &lt;&lt; m_name &lt;&lt; “，联系电话：” &lt;&lt; m_tel &lt;&lt; endl; }<br>
};</p>
<p>int main()<br>
{<br>
CGirl g;<br>
g.setname(“西施”);<br>
g.show();<br>
}</p>
<h2 id="继承方式">继承方式</h2>
<p>类成员的访问权限由高到低依次为：public --&gt; protected --&gt; private，public成员在类外可以访问，private成员只能在类的成员函数中访问。<br>
如果不考虑继承关系，protected成员和private成员一样，类外不能访问。但是，当存在继承关系时，protected和private就不一样了。基类中的protected成员可以在派生类中访问，而基类中的 private成员不能在派生类中访问。<br>
继承方式有三种：public（公有的）、protected（受保护的）和private（私有的）。它是可选的，如果不写，那么默认为private。不同的继承方式决定了在派生类中成员函数中访问基类成员的权限。<br>
1）基类成员在派生类中的访问权限不得高于继承方式中指定的权限。例如，当继承方式为protected时，那么基类成员在派生类中的访问权限最高也为protected，高于protected的会降级为protected，但低于protected不会升级。再如，当继承方式为public时，那么基类成员在派生类中的访问权限将保持不变。<br>
也就是说，继承方式中的public、protected、private是用来指明基类成员在派生类中的最高访问权限的。<br>
2) 不管继承方式如何，基类中的private成员在派生类中始终不能使用（不能在派生类的成员函数中访问或调用）。<br>
3) 如果希望基类的成员能够被派生类继承并且毫无障碍地使用，那么这些成员只能声明为public 或protected；只有那些不希望在派生类中使用的成员才声明为private。<br>
4) 如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为 protected。<br>
由于private和protected继承方式会改变基类成员在派生类中的访问权限，导致继承关系复杂，所以，在实际开发中，一般使用public。<br>
在派生类中，可以通过基类的公有成员函数间接访问基类的私有成员。<br>
使用 using 关键字可以改变基类成员在派生类中的访问权限。<br>
注意：using只能改变基类中public和protected成员的访问权限，不能改变private成员的访问权限，因为基类中的private成员在派生类中是不可见的，根本不能使用。<br>
示例：<br>
#include <iostream>         // 包含头文件。<br>
using namespace std;        // 指定缺省的命名空间。</iostream></p>
<p>class A  {        // 基类<br>
public:<br>
int m_a=10;<br>
protected:<br>
int m_b=20;<br>
private:<br>
int m_c = 30;<br>
};</p>
<p>class B :public A        // 派生类<br>
{<br>
public:<br>
using A::m_b;         // 把m_b的权限修改为公有的。<br>
private:<br>
using A::m_a;         // 把m_a的权限修改为私有的。<br>
};</p>
<p>int main()<br>
{<br>
B b;<br>
// b.m_a = 11;<br>
b.m_b = 21;<br>
//b.m_c = 21;<br>
}</p>
<h2 id="继承的对象模型">继承的对象模型</h2>
<p>1）创建派生类对象时，先调用基类的构造函数，再调用派生类的构造函数。<br>
2）销毁派生类对象时，先调用派生类的析构函数，再调用基类的析构函数。如果手工调用派生类的析构函数，也会调用基类的析构函数。<br>
3）创建派生类对象时只会申请一次内存，派生类对象包含了基类对象的内存空间，this指针相同的。<br>
4）创建派生类对象时，先初始化基类对象，再初始化派生类对象。<br>
5）在VS中，用cl.exe可以查看类的内存模型。<br>
6）对派生类对象用sizeof得到的是基类所有成员（包括私有成员）+派生类对象所有成员的大小。<br>
7）在C++中，不同继承方式的访问权限只是语法上的处理。<br>
8）对派生类对象用memset()会清空基类私有成员。<br>
9）用指针可以访问到基类中的私有成员（内存对齐）。</p>
<p>查看对象内存布局的方法：<br>
cl 源文件名 /d1 reportSingleClassLayout类名<br>
注意：类名不要太短，否则屏幕会显示一大堆东西，找起来很麻烦。<br>
例如，查看BBB类，源代码文件是demo01.cpp：<br>
cl demo01.cpp /d1 reportSingleClassLayoutBBB</p>
<p>cl命令环境变量：<br>
1）在PATH环境变量中增加cl.exe的目录<br>
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\bin\Hostx64\x64<br>
2）增加INCLUDE环境变量，内容如下：<br>
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\include<br>
C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared<br>
C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt<br>
C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\um<br>
C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\winrt<br>
3）增加LIB环境变量，内容如下：<br>
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\lib\x64<br>
C:\Program Files (x86)\Windows Kits\10\Lib\10.0.19041.0\um\x64<br>
C:\Program Files (x86)\Windows Kits\10\Lib\10.0.19041.0\ucrt\x64</p>
<p>示例：<br>
#include <iostream>         // 包含头文件。<br>
using namespace std;        // 指定缺省的命名空间。</iostream></p>
<p>void* operator new(size_t size)   // 重载new运算符。<br>
{<br>
void* ptr = malloc(size);        // 申请内存。<br>
cout &lt;&lt; “申请到的内存的地址是：” &lt;&lt; ptr &lt;&lt; “，大小是：” &lt;&lt; size &lt;&lt; endl;<br>
return ptr;<br>
}</p>
<p>void operator delete(void* ptr)   // 重载delete运算符。<br>
{<br>
if (ptr == 0) return;       // 对空指针delete是安全的。<br>
free(ptr);      // 释放内存。<br>
cout &lt;&lt; “释放了内存。\n”;<br>
}</p>
<p>class A {        // 基类<br>
public:<br>
int m_a = 10;<br>
protected:<br>
int m_b = 20;<br>
private:<br>
int m_c = 30;<br>
public:<br>
A() {<br>
cout &lt;&lt; "A中this指针是： " &lt;&lt; this &lt;&lt; endl;<br>
cout &lt;&lt; “A中m_a的地址是：” &lt;&lt; &amp;m_a &lt;&lt; endl;<br>
cout &lt;&lt; “A中m_b的地址是：” &lt;&lt; &amp;m_b &lt;&lt; endl;<br>
cout &lt;&lt; “A中m_c的地址是：” &lt;&lt; &amp;m_c &lt;&lt; endl;<br>
}<br>
void func() { cout &lt;&lt; “m_a=” &lt;&lt; m_a &lt;&lt; “,m_b=” &lt;&lt; m_b &lt;&lt; “,m_c=” &lt;&lt; m_c &lt;&lt; endl; }<br>
};</p>
<p>class B :public A        // 派生类<br>
{<br>
public:<br>
int m_d = 40;<br>
B() {<br>
cout &lt;&lt; "B中this指针是： " &lt;&lt; this &lt;&lt; endl;<br>
cout &lt;&lt; “B中m_a的地址是：” &lt;&lt; &amp;m_a &lt;&lt; endl;<br>
cout &lt;&lt; “B中m_b的地址是：” &lt;&lt; &amp;m_b &lt;&lt; endl;<br>
//cout &lt;&lt; “B中m_c的地址是：” &lt;&lt; &amp;m_c &lt;&lt; endl;<br>
cout &lt;&lt; “B中m_d的地址是：” &lt;&lt; &amp;m_d &lt;&lt; endl;<br>
}<br>
void func1() { cout &lt;&lt; “m_d=” &lt;&lt; m_d &lt;&lt; endl; }<br>
};</p>
<p>int main()<br>
{<br>
cout &lt;&lt; “基类占用内存的大小是：” &lt;&lt; sizeof(A) &lt;&lt; endl;<br>
cout &lt;&lt; “派生类占用内存的大小是：” &lt;&lt; sizeof(B) &lt;&lt; endl;</p>
<pre><code>B *p=new B;
p-&gt;func(); p-&gt;func1();
// memset(p, 0, sizeof(B));
*((int*)p + 2) = 31;        // 把基类私有成员m_c的值修改成31。
p-&gt;func(); p-&gt;func1();
delete p;
</code></pre>
<p>}</p>
<h2 id="如何构造基类">如何构造基类</h2>
<p>派生类构造函数的要点如下：<br>
1）创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数。<br>
2）如果没以指定基类构造函数，将使用基类的默认构造函数。<br>
3）可以用初始化列表指明要使用的基类构造函数。<br>
4）基类构造函数负责初始化被继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。<br>
5）派生类的构造函数总是调用一个基类构造函数，包括拷贝构造函数。</p>
<p>示例：<br>
#include <iostream>         // 包含头文件。<br>
using namespace std;        // 指定缺省的命名空间。</iostream></p>
<p>class A {        // 基类<br>
public:<br>
int m_a;<br>
private:<br>
int m_b;<br>
public:<br>
A() : m_a(0) , m_b(0)                     // 基类的默认构造函数。<br>
{<br>
cout &lt;&lt; “调用了基类的默认构造函数A()。\n”;<br>
}<br>
A(int a,int b) : m_a(a) , m_b(b)     // 基类有两个参数的构造函数。<br>
{<br>
cout &lt;&lt; “调用了基类的构造函数A(int a,int b)。\n”;<br>
}<br>
A(const A &amp;a) : m_a(a.m_a+1) , m_b(a.m_b+1)   // 基类的拷贝构造函数。<br>
{<br>
cout &lt;&lt; “调用了基类的拷贝构造函数A(const A &amp;a)。\n”;<br>
}</p>
<pre><code>// 显示基类A全部的成员。
void showA() { cout &lt;&lt; "m_a=" &lt;&lt; m_a &lt;&lt; ",m_b=" &lt;&lt; m_b &lt;&lt; endl; }
</code></pre>
<p>};</p>
<p>class B :public A        // 派生类<br>
{<br>
public:<br>
int m_c;<br>
B() : m_c(0) , A()             // 派生类的默认构造函数，指明用基类的默认构造函数（不指明也无所谓）。<br>
{<br>
cout &lt;&lt; “调用了派生类的默认构造函数B()。\n”;<br>
}<br>
B(int a, int b, int c) : A(a, b), m_c©           // 指明用基类的有两个参数的构造函数。<br>
{<br>
cout &lt;&lt; “调用了派生类的构造函数B(int a,int b,int c)。\n”;<br>
}<br>
B(const A&amp; a, int c) :A(a), m_c©              // 指明用基类的拷贝构造函数。<br>
{<br>
cout &lt;&lt; “调用了派生类的构造函数B(const A &amp;a,int c) 。\n”;<br>
}</p>
<pre><code>// 显示派生类B全部的成员。
void showB() { cout &lt;&lt; "m_c=" &lt;&lt; m_c &lt;&lt; endl &lt;&lt; endl; }
</code></pre>
<p>};</p>
<p>int main()<br>
{<br>
B b1;                 // 将调用基类默认的构造函数。<br>
b1.showA();     b1.showB();</p>
<pre><code>B b2(1, 2, 3);      // 将调用基类有两个参数的构造函数。
b2.showA();     b2.showB();
        
A a(10, 20);      // 创建基类对象。
B b3(a, 30);      // 将调用基类的拷贝造函数。
b3.showA();     b3.showB();
</code></pre>
<p>}</p>
<h2 id="名字遮蔽与类作用域">名字遮蔽与类作用域</h2>
<p>如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，通过派生类对象或者在派生类的成员函数中使用该成员时，将使用派生类新增的成员，而不是基类的。<br>
注意：基类的成员函数和派生类的成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数。<br>
类是一种作用域，每个类都有它自己的作用域，在这个作用域之内定义成员。<br>
在类的作用域之外，普通的成员只能通过对象（可以是对象本身，也可以是对象指针或对象引用）来访问，静态成员可以通过对象访问，也可以通过类访问。<br>
在成员名前面加类名和域解析符可以访问对象的成员。<br>
如果不存在继承关系，类名和域解析符可以省略不写。<br>
当存在继承关系时，基类的作用域嵌套在派生类的作用域中。如果成员在派生类的作用域中已经找到，就不会在基类作用域中继续查找；如果没有找到，则继续在基类作用域中查找。<br>
如果在成员的前面加上类名和域解析符，就可以直接使用该作用域的成员。<br>
示例：<br>
#include <iostream>         // 包含头文件。<br>
using namespace std;        // 指定缺省的命名空间。</iostream></p>
<p>class A {        // 基类<br>
public:<br>
int m_a=10;<br>
void func() { cout &lt;&lt; “调用了A的func()函数。\n”; }<br>
};</p>
<p>class B :public A {       // 子类<br>
public:<br>
int m_a = 20;<br>
void func() { cout &lt;&lt; “调用了B的func()函数。\n”; }<br>
};</p>
<p>class C :public B {       // 孙类<br>
public:<br>
int m_a = 30;<br>
void func() { cout &lt;&lt; “调用了C的func()函数。\n”; }<br>
void show() {<br>
cout &lt;&lt; “C::m_a的值是：” &lt;&lt; C::m_a &lt;&lt; endl;<br>
cout &lt;&lt; “B::m_a的值是：” &lt;&lt; B::m_a &lt;&lt; endl;<br>
cout &lt;&lt; “A::m_a的值是：” &lt;&lt; B::A::m_a &lt;&lt; endl;<br>
}<br>
};</p>
<p>int main()<br>
{<br>
C c;<br>
cout &lt;&lt; “C::m_a的值是：” &lt;&lt; c.C::m_a &lt;&lt; endl;<br>
cout &lt;&lt; “B::m_a的值是：” &lt;&lt; c.B::m_a &lt;&lt; endl;<br>
cout &lt;&lt; “A::m_a的值是：” &lt;&lt; c.B::A::m_a &lt;&lt; endl;<br>
c.C::func();<br>
c.B::func();<br>
c.B::A::func();<br>
}</p>
<h2 id="继承的特殊关系">继承的特殊关系</h2>
<p>派生类和基类之间有一些特殊关系。<br>
1）如果继承方式是公有的，派生类对象可以使用基类成员。<br>
2）可以把派生类对象赋值给基类对象（包括私有成员），但是，会舍弃非基类的成员。<br>
3）基类指针可以在不进行显式转换的情况下指向派生类对象。<br>
4）基类引用可以在不进行显式转换的情况下引用派生类对象。<br>
注意：<br>
1）基类指针或引用只能调用基类的方法，不能调用派生类的方法。<br>
2）可以用派生类构造基类。<br>
3）如果函数的形参是基类，实参可以用派生类。<br>
4）C++要求指针和引用类型与赋给的类型匹配，这一规则对继承来说是例外。但是，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针（没有价值，没有讨论的必要）。<br>
示例：<br>
#include <iostream>         // 包含头文件。<br>
using namespace std;        // 指定缺省的命名空间。</iostream></p>
<p>class A {        // 基类<br>
public:<br>
int m_a=0;<br>
private:<br>
int m_b=0;<br>
public:<br>
// 显示基类A全部的成员。<br>
void show() { cout &lt;&lt; “A::show() m_a=” &lt;&lt; m_a &lt;&lt; “,m_b=” &lt;&lt; m_b &lt;&lt; endl; }<br>
// 设置成员m_b的值。<br>
void setb(int b) { m_b = b;  }<br>
};</p>
<p>class B :public A        // 派生类<br>
{<br>
public:<br>
int m_c=0;<br>
// 显示派生类B全部的成员。<br>
void show() { cout &lt;&lt; “B::show() m_a=” &lt;&lt; m_a &lt;&lt; “m_c=” &lt;&lt; m_c &lt;&lt; endl; }<br>
};</p>
<p>int main()<br>
{<br>
B b;<br>
A* a = &amp;b;</p>
<pre><code>b.m_a = 10; 
b.setb(20);          // 设置成员m_b的值。
b.m_c = 30;
b.show();            // 调用的是B类的show()函数。

a-&gt;m_a = 11;
a-&gt;setb(22);          // 设置成员m_b的值。
// a-&gt;m_c = 30;

a-&gt;show();         // 调用的是A类的show()函数。
</code></pre>
<p>}</p>
<h2 id="多继承与虚继承">多继承与虚继承</h2>
<p>多继承的语法：<br>
class 派生类名 : [继承方式1] 基类名1, [继承方式2] 基类名2,…<br>
{<br>
派生类新增加的成员<br>
};</p>
<p>菱形继承<br>
虚继承可以解决菱形继承的二义性和数据冗余的问题。<br>
有了多继承，就存在菱形继承，有了菱形继承就有虚继承，增加了复杂性。<br>
不提倡使用多继承，只有在比较简单和不出现二义性的情况时才使用多继承，能用单一继承解决的问题就不要使用多继承。<br>
如果继承的层次很多、关系很复杂，程序的编写、调试和维护工作都会变得更加困难，由于这个原因，C++之后的很多面向对象的编程语言，例如 Java、C#、PHP 等，都不支持多继承。</p>
<p>多继承示例：<br>
#include <iostream>         // 包含头文件。<br>
using namespace std;        // 指定缺省的命名空间。</iostream></p>
<p>class A1 {        // 基类一<br>
public:<br>
int m_a = 10;<br>
};</p>
<p>class A2 {        // 基类二<br>
public:<br>
int m_a = 20;<br>
};</p>
<p>class B :public A1, public A2 {       // 派生类<br>
public:<br>
int m_a = 30;<br>
};</p>
<p>int main()<br>
{<br>
B b;<br>
cout &lt;&lt; " B::m_a的值是：" &lt;&lt; b.m_a &lt;&lt; endl;<br>
cout &lt;&lt; “A1::m_a的值是：” &lt;&lt; b.A1::m_a &lt;&lt; endl;<br>
cout &lt;&lt; “A2::m_a的值是：” &lt;&lt; b.A2::m_a &lt;&lt; endl;<br>
}</p>
<p>菱形继承示例：<br>
#include <iostream>         // 包含头文件。<br>
using namespace std;        // 指定缺省的命名空间。</iostream></p>
<p>class A {<br>
public:<br>
int m_a = 10;<br>
};</p>
<p>class B : virtual public A { };</p>
<p>class C : virtual public A { };</p>
<p>class DD : public B, public C {};</p>
<p>int main()<br>
{<br>
DD d;<br>
// d.B::m_a = 30;<br>
// d.C::m_a = 80;<br>
d.m_a = 80;<br>
cout &lt;&lt; “B::m_a的地址是：” &lt;&lt; &amp;d.B::m_a &lt;&lt; “，值是：” &lt;&lt; d.B::m_a &lt;&lt; endl;<br>
cout &lt;&lt; “C::m_a的地址是：” &lt;&lt; &amp;d.C::m_a &lt;&lt; “，值是：” &lt;&lt; d.C::m_a &lt;&lt; endl;<br>
}</p>

    </section>

    
        <section class="post-tag">
            <a href="/tags"><i class="fa fa-tags"></i></a>
            
                <a href="/tags/IT%EF%BC%8C-%E5%AD%A6%E4%B9%A0%EF%BC%8C-C/" class="tag-item">
                    IT， 学习， C++
                </a>
            
        </section>
    
    
        <section class="post-cate">
            <a href="/categories"><i class="fa fa-inbox"></i></a>
            
                <a href="/categories/IT%E6%8A%80%E6%9C%AF/" class="cate-item">
                    IT技术
                </a>
            
        </section>
    

    <section class="post-cc">
        <div class="post-cc-author">
            <span class="bold">作者：</span><a href="mailto:22232025@zju.edu.cn" title="锐哥">锐哥</a>
        </div>
        <div class="post-cc-link">
            <span class="bold">链接：</span><a href="/2024/01/08/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8815%EF%BC%89%E7%B1%BB%E7%BB%A7%E6%89%BF/">http://needrigor.github.io/2024/01/08/C-学习笔记（15）类继承/</a>
        </div>
        <div class="post-cc-source">
            <span class="bold">来源：</span><a href="/">锐哥的个人空间</a>
        </div>
        <div class="ppost-cc-declare">
            <span class="bold">版权声明: </span>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a> 许可协议。著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 
        </div>
    </section>

    <section class="flex-between" style="margin: 20px 0;">
        <div class="pre">
            
                <a href="/2024/01/08/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8816%EF%BC%89%E7%B1%BB%E5%A4%9A%E6%80%81/" class="change-link">
                    <span class="icon"><i class="fa fa-angle-double-left"></i></span>
                    <span class="text">
                        <span class="identify">上一篇</span>
                        <span class="text-title">C++学习笔记（16）类多态</span>
                    </span>
                </a>
            
        </div>
        <div class="next">
            
                <a href="/2024/01/08/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8814%EF%BC%89C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="change-link">
                    <span class="text">
                        <span class="identify" style="text-align: right;">下一篇</span>
                        <span class="text-title" style="text-align: right;">C++学习笔记（14）C++类型转换</span>
                    </span>
                    <span class="icon"><i class="fa fa-angle-double-right"></i></span>
                </a>
            
        </div>
    </section>

    <!-- comment -->
    <section class="comment-container">
        <!-- giscus -->
        
    </section>
</article>




            <section class="article-bottom flex-between">
                <div class="flex-center">
                    <img src="/imgs/logo.png" class="logo">
                    <span>保持好奇</span>
                </div>
                <div class="flex-center">
                    <a href="mailto:22232025@zju.edu.cn">
                        <span title="envelope">
                            <i class="fa fa-envelope" aria-hidden="true"></i>
                        </span>
                    </a>
                    <a target="_blank" rel="noopener" href="https://github.com/can-dy-jack/hexo-theme-delicate">
                        <span title="github" style="font-size: 18px;">
                            <i class="fa fa-github" aria-hidden="true"></i>
                        </span>
                    </a>
                </div>
            </section>
        </div>
    </main>

    <div class="to-top">
    <a href="javascript: void(0)" onclick="delicate.toTop()">
        <i class="fa fa-chevron-up" aria-hidden="true"></i>
    </a>
</div>

    <footer>
        <div class="footer-info gray">
    <div>
        <span><a target="_blank" rel="noopener" href="https://github.com/can-dy-jack/hexo-theme-delicate">Delicate</a> theme designed with ❤️ by <a target="_blank" rel="noopener" href="https://github.com/can-dy-jack">can-dy-jack</a></span>
    </div>
    <div>
        <span>Copyright Ⓒ 2024. All rights reserved.</span>
    </div>
</div>
    </footer>

    


<script src="/js/index.js"></script>


</body>

</html>