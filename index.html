<!DOCTYPE html>

<html lang="">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>锐哥的个人空间</title>

    
    <meta name="description" content="">
    <meta name="keywords" content="">
    <meta name="author" content="锐哥">

    <meta name="color-scheme" content="light dark">

    
    
<link rel="stylesheet" href="/styles/index.css">

    
    <link rel="shortcut icon" href="/imgs/logo.png">

    
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css">
    
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/styles/base16/solarized-light.css">
    

    
<meta name="generator" content="Hexo 7.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>


<body id="delicate-app">
    <main>
        <div class="container">
            <section class="page-top-badge flex-between w100">
                <div>
                    <a href="/">
                        <span title="github"><i class="fa fa-home" aria-hidden="true"></i></span>
                    </a>
                </div>
                <!-- <div>
                    
                </div> -->
            </section>
            <section class="index-title">
    <h2>锐哥的个人空间</h2>
    <div class="description"></h3>
</section>
<header>
    <nav>
        
        
            
            <a href="/archives/">archive</a>
        
            
             | <a href="/tags/">tags</a>
        
            
             | <a href="/categories/">categories</a>
        
            
             | <a href="/about/">关于我</a>
        
    </nav>
</header>
<div class="head-img">
    <img src="/imgs/beach.jpg">
</div>
<article class="index-article">
    <div class="article-list">
        
            
            
            <div class="article-item"> 
                <div class="article-item-title">
                    <h1>
                        <a href="/2024/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/">
                            数据结构与算法学习笔记（2）数组与链表
                        </a>
                    </h1>
                    <div class="info">
                        
                        
                            <span>
                                2024/01/11
                            </span>
                        
                    </div>
                </div>
                <div class="article-item-excerpt article">
                    <div>
                        <h1>数据与链表</h1>
<h2 id="一、数组">一、数组</h2>
<p>「数组 array」是一种线性数据结构，其将相同类型的元素存储在连续的内存空间中。我们将元素在数组中的位置称为该元素的「索引 index」。</p>
<h3 id="1-1-数组常用操作">1.1 数组常用操作</h3>
<h4 id="1-1-1-初始化数组">1.1.1 初始化数组</h4>
<p>两种初始化方式：无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为0：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>];                    <span class="comment">//存储在栈上</span></span><br><span class="line">    <span class="type">int</span> nums[<span class="number">5</span>] = {<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span> };<span class="comment">//存储在堆上，需要手动释放</span></span><br><span class="line">    <span class="type">int</span>* arr1 = <span class="keyword">new</span> <span class="type">int</span> [<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span>* nums1 = <span class="keyword">new</span> <span class="type">int</span> [<span class="number">5</span>] {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> };</span><br><span class="line">    cout &lt;&lt;arr[<span class="number">3</span>]&lt;&lt;nums[<span class="number">2</span>]&lt;&lt;arr1[<span class="number">3</span>]&lt;&lt;nums1[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line">    <span class="keyword">delete</span>[] nums1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-1-2-访问元素">1.1.2 访问元素</h4>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="53.168ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 23500.4 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">元</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">素</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">内</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">存</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">地</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">址</text></g><g data-mml-node="mo" transform="translate(6277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(7333.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g><g data-mml-node="mi" transform="translate(8333.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">组</text></g><g data-mml-node="mi" transform="translate(9333.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">内</text></g><g data-mml-node="mi" transform="translate(10333.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">存</text></g><g data-mml-node="mi" transform="translate(11333.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">地</text></g><g data-mml-node="mi" transform="translate(12333.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">址</text></g><g data-mml-node="mo" transform="translate(13555.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(14556,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">元</text></g><g data-mml-node="mi" transform="translate(15556,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">素</text></g><g data-mml-node="mi" transform="translate(16556,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">长</text></g><g data-mml-node="mi" transform="translate(17556,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">度</text></g><g data-mml-node="mo" transform="translate(18778.2,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(19500.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">元</text></g><g data-mml-node="mi" transform="translate(20500.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">素</text></g><g data-mml-node="mi" transform="translate(21500.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">索</text></g><g data-mml-node="mi" transform="translate(22500.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">引</text></g></g></g></svg></mjx-container><br>
<strong>索引本质上是内存地址的偏移量</strong>。在数组中访问元素非常高效，可以在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>时间内随即访问数组中的任意一个元素。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*随机访问元素*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">randomAccess</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> randomIndex = <span class="built_in">rand</span>() % size; <span class="comment">//在区间[0, size)中随机抽取一个数字</span></span><br><span class="line">    <span class="keyword">return</span> nums[randomIndex];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">9</span>] = {<span class="number">323</span>,<span class="number">234</span>,<span class="number">2</span>,<span class="number">32</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">563</span>,<span class="number">3</span>,<span class="number">2</span>};</span><br><span class="line">    cout &lt;&lt; <span class="built_in">randomAccess</span>(arr, <span class="number">7</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-1-3-插入元素">1.1.3. 插入元素</h4>
<p>由于数组的长度是固定的，因此插入一个元素必定会导致数组尾部元素“丢失”。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*在数组的索引index处插入元素*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> size, <span class="type">int</span> num, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = size; i &gt; index; i--) </span><br><span class="line">        nums[i] = nums[i<span class="number">-1</span>];</span><br><span class="line">    nums[index] = num;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">arr_cout</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* nums, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    cout&lt;&lt;nums[i]&lt;&lt;<span class="string">"、"</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">9</span>] = {<span class="number">323</span>,<span class="number">234</span>,<span class="number">2</span>,<span class="number">32</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">563</span>,<span class="number">3</span>,<span class="number">2</span>};</span><br><span class="line">    <span class="built_in">arr_cout</span>(arr,<span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">insert</span> (arr, <span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(<span class="type">int</span>), <span class="number">33</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">arr_cout</span>(arr,<span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-1-4-删除元素">1.1.4 删除元素</h4>
<p>若想删除索引<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>处的元素，则需要把索引<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>之后的元素都向前移动一位。<br>
注意：删除元素完成后，原先末尾的元素变得“无意义”了，所以无须特意去修改它。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除数组的索引index处元素*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> size, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = index; i &lt; size<span class="number">-1</span>; i++)</span><br><span class="line">        nums[i] = nums[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    nums[size<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">arr_cout</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* nums, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    cout&lt;&lt;nums[i]&lt;&lt;<span class="string">"、"</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">9</span>] = {<span class="number">323</span>,<span class="number">234</span>,<span class="number">2</span>,<span class="number">32</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">563</span>,<span class="number">3</span>,<span class="number">2</span>};</span><br><span class="line">    <span class="built_in">arr_cout</span>(arr,<span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">remove</span>(arr, <span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(<span class="type">int</span>),<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">arr_cout</span>(arr,<span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>数组的插入与删除操作有以下缺点：</p>
<ul>
<li><strong>时间复杂度高</strong>：数组的插入和删除的平均时间复杂度均为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，其中<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>为数组长度。</li>
<li><strong>丢失元素</strong>：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失。</li>
<li><strong>内存浪费</strong>：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是“无意义”的，但这样做会造成部分内存空间浪费。</li>
</ul>
<h4 id="1-1-5-遍历数组">1.1.5 遍历数组</h4>
<p>easy</p>
<h4 id="1-1-6-查找数组">1.1.6 查找数组</h4>
<p>在数组中查找指定元素需要遍历数组，每轮判断元素值是否匹配，若匹配则输出对应索引。<br>
因为数组是线性数据结构，所以上述查找操作被称为 <strong>“线性查找”</strong>。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*在数组中查找指定元素*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* nums, <span class="type">int</span> size, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++)</span><br><span class="line">        <span class="keyword">if</span>(target == nums[i]) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">9</span>] = {<span class="number">323</span>,<span class="number">234</span>,<span class="number">2</span>,<span class="number">32</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">563</span>,<span class="number">3</span>,<span class="number">2</span>};</span><br><span class="line">    cout &lt;&lt; <span class="built_in">find</span>(arr,<span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(<span class="type">int</span>), <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-1-7-扩容数组">1.1.7 扩容数组</h4>
<p><strong>数组的长度是不可变的。</strong><br>
如果我们希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次复制到新数组。这是一个<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>的操作，在数组很大的情况下非常耗时。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*在扩容数组*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">extend</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* nums, <span class="type">int</span> size, <span class="type">int</span> enlarge)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span>* res = <span class="keyword">new</span> <span class="type">int</span>[size + enlarge];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        res[i] = nums[i];</span><br><span class="line">    <span class="keyword">delete</span>[] nums;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">arr_cout</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* nums, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    cout&lt;&lt;nums[i]&lt;&lt;<span class="string">"、"</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">8</span>] = {<span class="number">323</span>,<span class="number">234</span>,<span class="number">2</span>,<span class="number">32</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">563</span>,<span class="number">33</span>};</span><br><span class="line">    <span class="type">int</span>* arr2 = <span class="built_in">extend</span>(arr, <span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(<span class="type">int</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">arr_cout</span>(arr2, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1-2-数组的优点与局限性">1.2 数组的优点与局限性</h3>
<p>数组存储在<strong>连续的内存空间</strong>内，且<strong>元素类型相同</strong>。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。</p>
<ul>
<li><strong>空间效率高</strong>：数组为数据分配了连续的内存块，无须额外的结构开销。</li>
<li><strong>支持随机访问</strong>：数组允许在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>时间内访问任何元素。</li>
<li><strong>缓存局部性</strong>：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。</li>
</ul>
<p>连续空间存储是一把双刃剑，其存在以下局限性。</p>
<ul>
<li><strong>插入与删除效率低</strong>：当数组中元素较多时，插入与删除操作需要移动大量的元素。</li>
<li><strong>长度不可变</strong>：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。</li>
<li><strong>空间浪费</strong>：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。</li>
</ul>
<h2 id="二、链表">二、链表</h2>
<p>「链表 linked list」是一种<strong>线性数据结构</strong>，其中的每个元素都是一个节点对象，各个节点通过<strong>指针</strong>相连接。指针记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。</p>
<p>链表的设计使得各个节点可以分散存储在内存各处，它们的<strong>内存地址无须连续</strong>。</p>
<p>链表节点<code>ListNode</code>除了包含值，还需额外保存一个引用（指针）。因此在相同数据量下，<strong>链表比数组占用更多的内存空间</strong>。</p>
<h3 id="2-1-链表常用操作">2.1 链表常用操作</h3>
<h4 id="2-1-1-初始化链表">2.1.1 初始化链表</h4>
<ol>
<li>初始化各个节点对象。</li>
<li>构建节点之间的指针关系。</li>
</ol>
<h4 id="2-1-2-插入节点">2.1.2 插入节点</h4>
<p><strong>只需要改变节点的指针</strong>即可(断开a-&gt;b,建立a-&gt;c)，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p>
<h4 id="2-1-3-删除节点">2.1.3 删除节点</h4>
<p>同理，改变指针即可。<strong>C++需要手动回收内存</strong>。<code>delete</code></p>
<h4 id="2-1-4-访问节点">2.1.4 访问节点</h4>
<p><strong>在链表中访问节点效率很低</strong>，程序需要从头节点出发，逐个向后遍历，直至找到目标节点。也就是说，访问链表的第<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>个节点需要循环<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.677ex" height="1.692ex" role="img" focusable="false" viewBox="0 -666 2067.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(567.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1567.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>轮，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p>
<h4 id="2-1-5-查找节点">2.1.5 查找节点</h4>
<p>遍历，线性查找。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*链表定义节点*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>{</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span> (<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>){</span><br><span class="line">        cout&lt;&lt;<span class="string">"创建一个节点"</span>&lt;&lt;endl;</span><br><span class="line">    };  <span class="comment">//构造函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ListNode* ni, ListNode* p)</span><span class="comment">//在ni节点后插入p节点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    p -&gt; next = ni -&gt; next;</span><br><span class="line">    ni -&gt; next = p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(ListNode *nj)</span><span class="comment">//删除nj节点之后的首个节点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (nj-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ListNode *p = nj-&gt;next;</span></span><br><span class="line">    <span class="comment">//ListNode *njj = p-&gt;next;</span></span><br><span class="line">    <span class="comment">//nj-&gt;next = njj;</span></span><br><span class="line">    nj-&gt;next = nj-&gt;next-&gt;next;</span><br><span class="line">    <span class="comment">//delete p;</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">access</span><span class="params">(ListNode* head, <span class="type">int</span> index)</span><span class="comment">//访问链表中索引为index的节点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(access == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(ListNode* head, <span class="type">int</span> target)</span><span class="comment">//查找链表中是否有target，若有，返回索引，若无，返回-1</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val == target) <span class="keyword">return</span> index;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        index ++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clean</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    ListNode *temp = <span class="literal">nullptr</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        temp = head;</span><br><span class="line">        head = head -&gt; next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    ListNode* n0 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    ListNode* n1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">    ListNode* n2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">23</span>);</span><br><span class="line">    ListNode* n3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">32</span>);</span><br><span class="line">    ListNode* n4 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">    n0 -&gt; next = n1;</span><br><span class="line">    n1 -&gt; next = n2;</span><br><span class="line">    n2 -&gt; next = n3;</span><br><span class="line">    n3 -&gt; next = n4;</span><br><span class="line">    <span class="comment">// n0-&gt; n1-&gt; n2-&gt; n3-&gt; n4</span></span><br><span class="line">  </span><br><span class="line">    ListNode* nb = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">insert</span>(n1, nb);</span><br><span class="line">    <span class="comment">//n0-&gt; n1-&gt; nb-&gt; n2-&gt; n3-&gt; n4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">remove</span>(n2);</span><br><span class="line">    <span class="comment">//n0-&gt; n1-&gt; nb-&gt; n2-&gt; n4</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">access</span>(n0, i) != <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">    ListNode* n = <span class="built_in">access</span>(n0, i);<span class="comment">//此时并没有创建新节点</span></span><br><span class="line">    cout &lt;&lt; n-&gt;val &lt;&lt; endl;</span><br><span class="line">    i++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">find</span>(n0, <span class="number">22</span>);</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">find</span>(n0, <span class="number">3232</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">"、"</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clean</span>(n0);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-数组VS-链表">2.2 数组VS.链表</h3>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left">数组</th>
<th style="text-align:left">链表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">存储方式</td>
<td style="text-align:left">连续内存空间</td>
<td style="text-align:left">分散内存空间</td>
</tr>
<tr>
<td style="text-align:center">容量扩展</td>
<td style="text-align:left">长度不可变</td>
<td style="text-align:left">可灵活扩展</td>
</tr>
<tr>
<td style="text-align:center">内存效率</td>
<td style="text-align:left">元素占用内存少，但可能浪费空间</td>
<td style="text-align:left">元素占用内存多</td>
</tr>
<tr>
<td style="text-align:center">访问元素</td>
<td style="text-align:left"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></td>
<td style="text-align:left"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></td>
</tr>
<tr>
<td style="text-align:center">添加元素</td>
<td style="text-align:left"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></td>
<td style="text-align:left"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></td>
</tr>
<tr>
<td style="text-align:center">删除元素</td>
<td style="text-align:left"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></td>
<td style="text-align:left"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></td>
</tr>
</tbody>
</table>
<h3 id="2-3常见链表类型">2.3常见链表类型</h3>
<ul>
<li>单向链表</li>
<li>环形链表</li>
<li>双向链表</li>
</ul>
<p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_common_types.png" alt="图片1" title="常见链表种类
"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 双向链表节点结构体 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> {</span><br><span class="line">    <span class="type">int</span> val;         <span class="comment">// 节点值</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向后继节点的指针</span></span><br><span class="line">    ListNode *prev;  <span class="comment">// 指向前驱节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>) {}  <span class="comment">// 构造函数</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-4-链表典型应用">2.4 链表典型应用</h3>
<p><strong>1. 单向链表</strong>通常用于实现栈、队列、哈希表和图等数据结构。</p>
<ul>
<li><strong>栈与队列</strong>：当插入和删除操作都在链表的一端进行时，它表现出先进后出的特性，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现出先进先出的特性，对应队列。</li>
<li><strong>哈希表</strong>：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。</li>
<li><strong>图</strong>：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。</li>
</ul>
<p><strong>2. 双向链表</strong>常用于需要快速查找前一个和后一个元素的场景。</p>
<ul>
<li><strong>高级数据结构</strong>：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。</li>
<li><strong>浏览器历史</strong>：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。</li>
<li><strong>LRU算法</strong>：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。</li>
</ul>
<p><strong>3. 环形链表</strong>常用于需要周期性操作的场景，比如操作系统的资源调度。</p>
<ul>
<li><strong>时间片轮转调度算法</strong>：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。</li>
<li><strong>数据缓冲区</strong>：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。</li>
</ul>
<h2 id="三、列表">三、列表</h2>
<p>「列表 list」是一个<strong>抽象的数据结构概念</strong>，它表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。列表可以基于链表或数组实现。</p>
<h3 id="3-1-列表的常用操作">3.1 列表的常用操作</h3>
<h4 id="3-1-1-初始化操作">3.1.1 初始化操作</h4>
<h4 id="3-1-2-访问元素">3.1.2 访问元素</h4>
<p>本质上是数组，所以可以在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>时间内访问和更新元素，效率很高。</p>
<h4 id="3-1-3-插入和删除元素">3.1.3 插入和删除元素</h4>
<p>相较于数组，列表可以自由地添加与删除元素。在列表尾部添加元素的时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，但插入和删除元素的效率仍与数组相同，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p>
<h4 id="3-1-4-遍历列表">3.1.4 遍历列表</h4>
<h4 id="3-1-5-拼接列表">3.1.5 拼接列表</h4>
<h4 id="3-1-6-排序列表">3.1.6 排序列表</h4>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums1;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>};<span class="comment">//初始化列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> num = nums[<span class="number">2</span>];<span class="comment">//访问列表</span></span><br><span class="line">    nums[<span class="number">1</span>] =<span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    nums.<span class="built_in">clear</span>();<span class="comment">//清空列表</span></span><br><span class="line"></span><br><span class="line">    nums.<span class="built_in">push_back</span>(<span class="number">11</span>);</span><br><span class="line">    nums.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    nums.<span class="built_in">push_back</span>(<span class="number">34</span>);</span><br><span class="line">    nums.<span class="built_in">push_back</span>(<span class="number">343</span>);</span><br><span class="line">    nums.<span class="built_in">push_back</span>(<span class="number">2343</span>);<span class="comment">//在尾部添加元素</span></span><br><span class="line"></span><br><span class="line">    nums.<span class="built_in">insert</span>(nums.<span class="built_in">begin</span>()+<span class="number">3</span>, <span class="number">56</span>);<span class="comment">//索引3处插入56</span></span><br><span class="line"></span><br><span class="line">    nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>()+<span class="number">4</span>);<span class="comment">//删除索引4的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*通过索引遍历列表*/</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; nums[i] &lt;&lt; <span class="string">"、"</span> ;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*直接遍历列表元素*/</span></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) cout &lt;&lt; num &lt;&lt; <span class="string">"、"</span> ;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*拼接列表*/</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums2 = {<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">312</span>, <span class="number">1</span>};</span><br><span class="line">    nums.<span class="built_in">insert</span>(nums.<span class="built_in">end</span>(), nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//将列表nums2插入到nums后面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*直接遍历列表元素*/</span></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) cout &lt;&lt; num &lt;&lt; <span class="string">"、"</span> ;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*列表排序*/</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">//从小到大排列</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*直接遍历列表元素*/</span></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) cout &lt;&lt; num &lt;&lt; <span class="string">"、"</span> ;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-2-列表实现">3.2 列表实现</h3>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 列表类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span> {</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *arr;             <span class="comment">// 数组（存储列表元素）</span></span><br><span class="line">    <span class="type">int</span> arrCapacity = <span class="number">10</span>; <span class="comment">// 列表容量</span></span><br><span class="line">    <span class="type">int</span> arrSize = <span class="number">0</span>;      <span class="comment">// 列表长度（当前元素数量）</span></span><br><span class="line">    <span class="type">int</span> extendRatio = <span class="number">2</span>;   <span class="comment">// 每次列表扩容的倍数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">MyList</span>() {</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[arrCapacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构方法 */</span></span><br><span class="line">    ~<span class="built_in">MyList</span>() {</span><br><span class="line">        <span class="keyword">delete</span>[] arr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取列表长度（当前元素数量）*/</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> arrSize;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取列表容量 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> arrCapacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>{</span><br><span class="line">        <span class="comment">// 索引如果越界，则抛出异常，下同</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">"索引越界"</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新元素 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> num)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">"索引越界"</span>);</span><br><span class="line">        arr[index] = num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在尾部添加元素 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>{</span><br><span class="line">        <span class="comment">// 元素数量超出容量时，触发扩容机制</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>() == <span class="built_in">capacity</span>())</span><br><span class="line">            <span class="built_in">extendCapacity</span>();</span><br><span class="line">        arr[<span class="built_in">size</span>()] = num;</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        arrSize++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在中间插入元素 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> num)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">"索引越界"</span>);</span><br><span class="line">        <span class="comment">// 元素数量超出容量时，触发扩容机制</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>() == <span class="built_in">capacity</span>())</span><br><span class="line">            <span class="built_in">extendCapacity</span>();</span><br><span class="line">        <span class="comment">// 将索引 index 以及之后的元素都向后移动一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= index; j--) {</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        }</span><br><span class="line">        arr[index] = num;</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        arrSize++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">"索引越界"</span>);</span><br><span class="line">        <span class="type">int</span> num = arr[index];</span><br><span class="line">        <span class="comment">// 将索引 index 之后的元素都向前移动一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = index; j &lt; <span class="built_in">size</span>() - <span class="number">1</span>; j++) {</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        arrSize--;</span><br><span class="line">        <span class="comment">// 返回被删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 列表扩容 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extendCapacity</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 新建一个长度为原数组 extendRatio 倍的新数组</span></span><br><span class="line">        <span class="type">int</span> newCapacity = <span class="built_in">capacity</span>() * extendRatio;</span><br><span class="line">        <span class="type">int</span> *tmp = arr;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[newCapacity];</span><br><span class="line">        <span class="comment">// 将原数组中的所有元素复制到新数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); i++) {</span><br><span class="line">            arr[i] = tmp[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">delete</span>[] tmp;</span><br><span class="line">        arrCapacity = newCapacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将列表转换为 Vector 用于打印 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 仅转换有效长度范围内的列表元素</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); i++) {</span><br><span class="line">            vec[i] = arr[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="四、内存与缓存">四、内存与缓存</h2>
<p><strong>物理结构在很大程度上决定了程序对内存和缓存的使用效率，进而影响算法程序的整体性能。</strong></p>
<h3 id="4-1-计算机存储设备">4.1 计算机存储设备</h3>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left">硬盘</th>
<th style="text-align:left">内存</th>
<th style="text-align:left">缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用途</td>
<td style="text-align:left">长期存储数据，包括操作系统、程序、文件等</td>
<td style="text-align:left">临时存储当前运行的程序和正在处理的数据</td>
<td style="text-align:left">存储经常访问的数据和指令，减少 CPU 访问内存的次数</td>
</tr>
<tr>
<td style="text-align:center">易失性</td>
<td style="text-align:left">断电后数据不会丢失</td>
<td style="text-align:left">断电后数据会丢失</td>
<td style="text-align:left">断电后数据会丢失</td>
</tr>
<tr>
<td style="text-align:center">容量</td>
<td style="text-align:left">较大，TB 级别</td>
<td style="text-align:left">较小，GB 级别</td>
<td style="text-align:left">非常小，MB 级别</td>
</tr>
<tr>
<td style="text-align:center">速度</td>
<td style="text-align:left">较慢，几百到几千MB/s</td>
<td style="text-align:left">较快，几十GB/s</td>
<td style="text-align:left">非常快，几十到几百GB/s</td>
</tr>
<tr>
<td style="text-align:center">价格</td>
<td style="text-align:left">较便宜，几毛到几元/GB</td>
<td style="text-align:left">较贵，几十到几百元/GB</td>
<td style="text-align:left">非常贵，随 CPU 打包计价</td>
</tr>
</tbody>
</table>
<p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/ram_and_cache.assets/computer_storage_devices.png" alt="图片2" title="硬盘、内存和缓存之间的数据流通"></p>
<h3 id="4-2-数据结构的内存效率">4.2 数据结构的内存效率</h3>
<p>在内存空间利用方面，数组和链表各自具有优势和局限性。</p>
<p><strong>数组</strong>的元素紧密排列，不需要额外的空间来存储链表节点间的引用（指针），因此<strong>空间效率更高</strong>。</p>
<p><strong>数组</strong>需要一次性分配足够的连续内存空间，这可能导致<strong>内存浪费</strong>，数组扩容也需要额外的时间和空间成本。</p>
<p><strong>链表</strong>以“节点”为单位进行动态内存分配和回收，提供了更大的<strong>灵活性</strong>。</p>
<p>在程序运行时，随着反复申请与释放内存，空闲内存的<strong>碎片化</strong>程度会越来越高，从而导致内存的利用效率降低。</p>
<p><strong>数组</strong>由于其连续的存储方式，相对<strong>不容易导致内存碎片化</strong>。<br>
<strong>链表</strong>的元素是分散存储的，在频繁的插入与删除操作中，<strong>更容易导致内存碎片化</strong>。</p>
<h3 id="4-3-数据结构的缓存效率">4.3 数据结构的缓存效率</h3>
<p>缓存虽然在空间容量上远小于内存，但它比内存快得多，在程序执行速度上起着至关重要的作用。由于缓存的容量有限，只能存储一小部分频繁访问的数据，因此<strong>当 CPU 尝试访问的数据不在缓存中时，就会发生「缓存未命中 cache miss」</strong>，此时 CPU 不得不从速度较慢的内存中加载所需数据。</p>
<p>显然，<strong>“缓存未命中”越少，CPU 读写数据的效率就越高，程序性能也就越好</strong>。我们将 CPU 从缓存中成功获取数据的比例称为**「缓存命中率 cache hit rate」**，这个指标通常用来衡量缓存效率。</p>
<p>为了尽可能达到更高的效率，缓存会采取以下数据加载机制。</p>
<ul>
<li><strong>缓存行</strong>：缓存不是单个字节地存储与加载数据，而是以缓存行为单位。相比于单个字节的传输，缓存行的传输形式更加高效。</li>
<li><strong>预取机制</strong>：处理器会尝试预测数据访问模式（例如顺序访问、固定步长跳跃访问等），并根据特定模式将数据加载至缓存之中，从而提升命中率。</li>
<li><strong>空间局部性</strong>：如果一个数据被访问，那么它附近的数据可能近期也会被访问。因此，缓存在加载某一数据时，也会加载其附近的数据，以提高命中率。</li>
<li><strong>时间局部性</strong>：如果一个数据被访问，那么它在不久的将来很可能再次被访问。缓存利用这一原理，通过保留最近访问过的数据来提高命中率。</li>
</ul>
<p>实际上，数组和链表对缓存的利用效率是不同的，主要体现在以下几个方面。</p>
<ul>
<li><strong>占用空间</strong>：链表元素比数组元素占用空间更多，导致缓存中容纳的有效数据量更少。</li>
<li><strong>缓存行</strong>：链表数据分散在内存各处，而缓存是“按行加载”的，因此加载到无效数据的比例更高。</li>
<li><strong>预取机制</strong>：数组比链表的数据访问模式更具“可预测性”，即系统更容易猜出即将被加载的数据。</li>
<li><strong>空间局部性</strong>：数组被存储在集中的内存空间中，因此被加载数据附近的数据更有可能即将被访问。<br>
总体而言，<strong>数组具有更高的缓存命中率</strong>，因此它在操作效率上通常优于链表。这使得在解决算法问题时，<strong>基于数组实现的数据结构往往更受欢迎</strong>。</li>
</ul>
<p>需要注意的是，<strong>高缓存效率并不意味着数组在所有情况下都优于链表</strong>。实际应用中选择哪种数据结构，应根据具体需求来决定。例如，数组和链表都可以实现“栈”数据结构（下一章会详细介绍），但它们适用于不同场景。</p>
<ul>
<li>在做算法题时，我们会倾向于选择基于数组实现的栈，因为它提供了更高的操作效率和随机访问的能力，代价仅是需要预先为数组分配一定的内存空间。</li>
<li>如果数据量非常大、动态性很高、栈的预期大小难以估计，那么基于链表实现的栈更加合适。链表能够将大量数据分散存储于内存的不同部分，并且避免了数组扩容产生的额外开销。</li>
</ul>

                    </div>
                </div>
            </div>

            <div style="text-align: right;">
                <button type="button" class="read-more">
                    <a href="/2024/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/">阅读更多</a>
                </button>
            </div>
        
            
            
                <hr>
            
            <div class="article-item"> 
                <div class="article-item-title">
                    <h1>
                        <a href="/2024/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%E5%9B%BE/">
                            数据结构与算法学习笔记（7）图
                        </a>
                    </h1>
                    <div class="info">
                        
                        
                            <span>
                                2024/01/10
                            </span>
                        
                    </div>
                </div>
                <div class="article-item-excerpt article">
                    <div>
                        
                    </div>
                </div>
            </div>

            <div style="text-align: right;">
                <button type="button" class="read-more">
                    <a href="/2024/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%E5%9B%BE/">阅读更多</a>
                </button>
            </div>
        
            
            
                <hr>
            
            <div class="article-item"> 
                <div class="article-item-title">
                    <h1>
                        <a href="/2024/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%E5%A0%86/">
                            数据结构与算法学习笔记（6）堆
                        </a>
                    </h1>
                    <div class="info">
                        
                        
                            <span>
                                2024/01/10
                            </span>
                        
                    </div>
                </div>
                <div class="article-item-excerpt article">
                    <div>
                        
                    </div>
                </div>
            </div>

            <div style="text-align: right;">
                <button type="button" class="read-more">
                    <a href="/2024/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%E5%A0%86/">阅读更多</a>
                </button>
            </div>
        
            
            
                <hr>
            
            <div class="article-item"> 
                <div class="article-item-title">
                    <h1>
                        <a href="/2024/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%E6%A0%91/">
                            数据结构与算法学习笔记（5）树
                        </a>
                    </h1>
                    <div class="info">
                        
                        
                            <span>
                                2024/01/10
                            </span>
                        
                    </div>
                </div>
                <div class="article-item-excerpt article">
                    <div>
                        
                    </div>
                </div>
            </div>

            <div style="text-align: right;">
                <button type="button" class="read-more">
                    <a href="/2024/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%E6%A0%91/">阅读更多</a>
                </button>
            </div>
        
            
            
                <hr>
            
            <div class="article-item"> 
                <div class="article-item-title">
                    <h1>
                        <a href="/2024/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%E5%93%88%E5%B8%8C%E8%A1%A8/">
                            数据结构与算法学习笔记（4）哈希表
                        </a>
                    </h1>
                    <div class="info">
                        
                        
                            <span>
                                2024/01/10
                            </span>
                        
                    </div>
                </div>
                <div class="article-item-excerpt article">
                    <div>
                        
                    </div>
                </div>
            </div>

            <div style="text-align: right;">
                <button type="button" class="read-more">
                    <a href="/2024/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%E5%93%88%E5%B8%8C%E8%A1%A8/">阅读更多</a>
                </button>
            </div>
        
            
            
                <hr>
            
            <div class="article-item"> 
                <div class="article-item-title">
                    <h1>
                        <a href="/2024/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/">
                            数据结构与算法学习笔记（3）栈与队列
                        </a>
                    </h1>
                    <div class="info">
                        
                        
                            <span>
                                2024/01/10
                            </span>
                        
                    </div>
                </div>
                <div class="article-item-excerpt article">
                    <div>
                        
                    </div>
                </div>
            </div>

            <div style="text-align: right;">
                <button type="button" class="read-more">
                    <a href="/2024/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/">阅读更多</a>
                </button>
            </div>
        
            
            
                <hr>
            
            <div class="article-item"> 
                <div class="article-item-title">
                    <h1>
                        <a href="/2024/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E7%BB%AA%E8%AE%BA/">
                            数据结构与算法学习笔记（1）绪论
                        </a>
                    </h1>
                    <div class="info">
                        
                        
                            <span>
                                2024/01/10
                            </span>
                        
                    </div>
                </div>
                <div class="article-item-excerpt article">
                    <div>
                        <h1>绪论</h1>
<p>数据结构与算法大概介绍，时间复杂度和空间复杂度，数据结构的基本概念。</p>
<h2 id="一、算法是什么">一、算法是什么</h2>
<h3 id="1-1算法定义">1.1算法定义</h3>
<p>「算法 algorithm」是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性。</p>
<ul>
<li>问题是明确的，包含清晰的输入和输出定义。</li>
<li>具有可行性，能够在有限步骤、时间和内存空间下完成。</li>
<li>各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。</li>
</ul>
<h3 id="1-2-数据结构定义">1.2   数据结构定义</h3>
<p>「数据结构 data structure」是计算机中组织和存储数据的方式，具有以下设计目标。</p>
<ul>
<li>空间占用尽量少，以节省计算机内存。</li>
<li>数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。</li>
<li>提供简洁的数据表示和逻辑信息，以便算法高效运行。</li>
</ul>
<p>数据结构设计是一个充满<strong>权衡</strong>的过程。如果想在某方面取得提升，往往需要在另一方面作出妥协。</p>
<h3 id="1-3-数据结构与算法的关系">1.3   数据结构与算法的关系</h3>
<p>如图 1-4 所示，数据结构与算法高度相关、紧密结合，具体表现在以下三个方面。</p>
<ul>
<li>数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。</li>
<li>算法是数据结构发挥作用的舞台。数据结构本身仅存储数据信息，结合算法才能解决特定问题。</li>
<li>算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。</li>
</ul>
<h2 id="二、复杂度分析">二、复杂度分析</h2>
<h3 id="2-1-算法效率评估">2.1 算法效率评估</h3>
<p>算法效率是衡量算法优劣的主要评价指标，它包括以下两个维度。</p>
<ul>
<li>时间效率：算法运行速度的快慢。</li>
<li>空间效率：算法占用内存空间的大小。</li>
</ul>
<p>效率评估方法主要分为两种：实际测试、理论估算。</p>
<h3 id="2-2-迭代和递归">2.2 迭代和递归</h3>
<h4 id="2-2-1-迭代">2.2.1 迭代</h4>
<ol>
<li><code>for</code>循环</li>
<li><code>while</code>循环</li>
<li>嵌套循环</li>
</ol>
<h4 id="2-2-2-递归">2.2.2 递归</h4>
<p>「递归 recursion」是一种算法策略，通过<strong>函数调用自身</strong>来解决问题。它主要包含两个阶段。</p>
<ol>
<li>递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li>
<li>归：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。</li>
</ol>
<p>而从实现的角度看，递归代码主要包含三个要素。</p>
<ul>
<li>终止条件：用于决定什么时候由“递”转“归”。</li>
<li>递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数。</li>
<li>返回结果：对应“归”，将当前递归层级的结果返回至上一层。</li>
</ul>
<p>例如：计算1+2+…+n</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 递归 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recur</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递：递归调用</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recur</span>(n - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 归：返回结果</span></span><br><span class="line">    <span class="keyword">return</span> n + res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="1-调用栈">(1) 调用栈</h5>
<p>递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。</p>
<p>函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，递归通常比迭代更加耗费内存空间。</p>
<p>递归调用函数会产生额外的开销。因此<strong>递归通常比循环的时间效率更低</strong>。</p>
<h5 id="2-尾递归">(2) 尾递归</h5>
<p>如果函数在返回前的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为「尾递归 tail recursion」。</p>
<ul>
<li>普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。</li>
<li>尾递归：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 尾递归 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tailRecur</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> res)</span> </span>{</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 尾递归调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tailRecur</span>(n - <span class="number">1</span>, res + n);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-3-时间复杂度">2.3 时间复杂度</h3>
<h4 id="2-3-1-定义">2.3.1 定义</h4>
<p><strong>算法运行时间随着数据量变大时的增长趋势。</strong><br>
时间复杂度分析本质上是<strong>计算“操作数量”的渐近上界</strong>，它具有明确的数学定义。</p>
<h4 id="2-3-2-计算步骤">2.3.2 计算步骤</h4>
<ul>
<li>第一步：统计操作数<br>
1.忽略<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.71ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2082 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mo" transform="translate(704,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1093,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1693,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>中的常数项和系数<br>
2.嵌套循环使用乘法</li>
<li>第二步：判断渐近上界<br>
保留最高阶项</li>
</ul>
<h4 id="2-3-3-常见类型">2.3.3 常见类型</h4>
<p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_common_types.png" alt="图片1" title="常见时间复杂度类型"></p>
<h5 id="1-常数阶-O-1">(1) 常数阶<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></h5>
<p>常数阶的操作数量与输入数据<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>大小无关，即不随着<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>的变化而变化。</p>
<h5 id="2-线性阶-O-n">(2) 线性阶<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></h5>
<p>线性阶的操作数量相对于输入数据大小n以线性级别增长。线性阶通常出现在单层循环中：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线性阶 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">linear</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="3-平方阶-O-n-2">(3) 平方阶<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></h5>
<p>平方阶的操作数量相对于输入数据大小<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>以平方级别增长。平方阶通常出现在嵌套循环中，外层循环和内层循环的时间复杂度都为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，因此总体的时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 平方阶 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quadratic</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环次数与数组长度成平方关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="4-指数阶-O-2-n">(4) 指数阶<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.765ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2548.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(2159.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></h5>
<p>生物学的“细胞分裂”是指数阶增长的典型例子：初始状态为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewBox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>个细胞，分裂一轮后变为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewBox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container>个，分裂两轮后变为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.532ex" role="img" focusable="false" viewBox="0 -677 500 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g></svg></mjx-container>个，以此类推，分裂<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>轮后有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.279ex" height="1.528ex" role="img" focusable="false" viewBox="0 -675.5 1007.3 675.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>个细胞。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 指数阶（递归实现） */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">expRecur</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">expRecur</span>(n - <span class="number">1</span>) + <span class="built_in">expRecur</span>(n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对于数据规模较大的问题，指数阶是不可接受的。</p>
<h5 id="5-对数阶-O-log-n">(5) 对数阶<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.112ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3585.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(2430,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(2596.7,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3196.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></h5>
<p>与指数阶相反，对数阶反映了“每轮缩减到一半”的情况。设输入数据大小为n，由于每轮缩减到一半，因此循环次数是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.546ex;" xmlns="http://www.w3.org/2000/svg" width="5.614ex" height="2.116ex" role="img" focusable="false" viewBox="0 -694 2481.2 935.4"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mn" transform="translate(1311,-241.4) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(1714.6,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(1881.2,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>，即<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.279ex" height="1.528ex" role="img" focusable="false" viewBox="0 -675.5 1007.3 675.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>的反函数。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对数阶（递归实现） */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">logRecur</span><span class="params">(<span class="type">float</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">logRecur</span>(n / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="6-线性对数阶-O-n-log-n">(6) 线性对数阶<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.847ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4352.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1918.7,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(3196.7,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(3363.3,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3963.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></h5>
<p>线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.112ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3585.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(2430,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(2596.7,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3196.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线性对数阶 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">linearLogRecur</span><span class="params">(<span class="type">float</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">linearLogRecur</span>(n / <span class="number">2</span>) + <span class="built_in">linearLogRecur</span>(n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        count++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="7-阶乘阶-O-n">(7) 阶乘阶<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.473ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2419 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="21" d="M78 661Q78 682 96 699T138 716T180 700T199 661Q199 654 179 432T158 206Q156 198 139 198Q121 198 119 206Q118 209 98 431T78 661ZM79 61Q79 89 97 105T141 121Q164 119 181 104T198 61Q198 31 181 16T139 1Q114 1 97 16T79 61Z"></path></g><g data-mml-node="mo" transform="translate(2030,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></h5>
<p>阶乘通常使用递归实现。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 阶乘阶（递归实现） */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorialRecur</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从 1 个分裂出 n 个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        count += <span class="built_in">factorialRecur</span>(n - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>阶乘阶比指数阶增长得更快，在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>较大时也是不可接受的。</p>
<h4 id="2-3-4-最差、最佳和平均时间复杂度">2.3.4 最差、最佳和平均时间复杂度</h4>
<p>一般用最差或者平均，平均比较难算，所以用最差时间复杂度。</p>
<h3 id="2-4-空间复杂度">2.4 空间复杂度</h3>
<p>「空间复杂度 space complexity」用于衡量算法<strong>占用内存空间</strong>随着数据量变大时的<strong>增长趋势</strong>。</p>
<h4 id="2-4-1-算法相关空间">2.4.1 算法相关空间</h4>
<p>算法在运行过程中使用的内存空间主要包括以下几种。</p>
<ul>
<li>输入空间：用于存储算法的<strong>输入数据</strong>。</li>
<li>暂存空间：用于存储算法在运行过程中的<strong>变量</strong>、<strong>对象</strong>、<strong>函数上下文</strong>等数据。</li>
<li>输出空间：用于存储算法的<strong>输出数据</strong>。</li>
</ul>
<p>一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。</p>
<p>暂存空间可以进一步划分为三个部分。</p>
<ul>
<li>暂存数据：用于保存算法运行过程中的各种<strong>常量</strong>、<strong>变量</strong>、<strong>对象</strong>等。</li>
<li>栈帧空间：用于保存调用函数的<strong>上下文数据</strong>。<u>系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。</u></li>
<li>指令空间：用于保存<strong>编译后的程序指令</strong>，在实际统计中通常<strong>忽略不计</strong>。</li>
</ul>
<p>在分析一段程序的空间复杂度时，我们通常统计<strong>暂存数据</strong>、<strong>栈帧空间</strong>和<strong>输出数据</strong>三部分。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 结构体 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node *next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 执行某些操作...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> n)</span> </span>{        <span class="comment">// 输入数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>;          <span class="comment">// 暂存数据（常量）</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;                <span class="comment">// 暂存数据（变量）</span></span><br><span class="line">    Node* node = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>); <span class="comment">// 暂存数据（对象）</span></span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">func</span>();           <span class="comment">// 栈帧空间（调用函数）</span></span><br><span class="line">    <span class="keyword">return</span> a + b + c;         <span class="comment">// 输出数据</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-5-权衡时间与空间">2.5 权衡时间与空间</h3>
<p>理想情况下，我们希望算法的时间复杂度和空间复杂度都能达到最优。然而在实际情况中，同时优化时间复杂度和空间复杂度通常非常困难。</p>
<p>降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然。我们将牺牲内存空间来提升算法运行速度的思路称为“以空间换时间”；反之，则称为“以时间换空间”。</p>
<p>选择哪种思路取决于我们更看重哪个方面。在大多数情况下，时间比空间更宝贵，因此“以空间换时间”通常是更常用的策略。当然，在数据量很大的情况下，控制空间复杂度也非常重要。</p>
<h2 id="三、数据结构基本概念">三、数据结构基本概念</h2>
<h3 id="3-1-数据结构分类">3.1 数据结构分类</h3>
<p>常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从“逻辑结构”和“物理结构”两个维度进行分类。</p>
<h4 id="3-1-1-逻辑结构：线性与非线性">3.1.1 逻辑结构：线性与非线性</h4>
<p>逻辑结构揭示了数据元素之间的逻辑关系。<br>
逻辑结构可分为“线性”和“非线性”两大类。线性结构比较直观，指<strong>数据在逻辑关系上呈线性排列</strong>；非线性结构则相反，呈非线性排列。</p>
<blockquote>
<p><strong>线性数据结构</strong>：数组、链表、栈、队列、哈希表，元素之间是<strong>一对一</strong>的顺序关系。<br>
<strong>非线性数据结构</strong>：</p>
<blockquote>
<p>树形结构：树、堆、哈希表，元素之间是<strong>一对多</strong>的关系。<br>
网状结构：图，元素之间是<strong>多对多</strong>的关系。</p>
</blockquote>
</blockquote>
<p><img src="https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_logic_structure.png" alt="图像2" title="线性数据结构与非线性数据结构"></p>
<h4 id="3-1-2-物理（存储）结构：连续与分散">3.1.2 物理（存储）结构：连续与分散</h4>
<p>物理结构反映了数据在计算机内存中的存储方式，可分为<strong>连续空间存储（数组）<strong>和</strong>分散空间存储（链表）</strong>。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出<strong>互补</strong>的特点<br>
<img src="https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_phisical_structure.png" alt="图像3" title="连续空间存储与分散空间存储"><br>
==<strong>所有数据结构都是基于数组、链表或二者的组合实现的。</strong>==</p>
<ul>
<li>基于<strong>数组</strong>可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.09ex;" xmlns="http://www.w3.org/2000/svg" width="3.52ex" height="1.595ex" role="img" focusable="false" viewBox="0 -665 1555.8 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g><g data-mml-node="mn" transform="translate(1055.8,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></svg></mjx-container> 的数组）等。</li>
<li>基于<strong>链表</strong>可实现：栈、队列、哈希表、树、堆、图等。</li>
</ul>
<p>静态数据结构和动态数据结构：</p>
<ul>
<li><strong>静态数据结构</strong>：基于数组实现的，此类数据结构在初始化后长度不可变。</li>
<li><strong>动态数据结构</strong>：基于链表实现的，这类数据结构在初始化后，仍可以在程序运行过程中对其长度进行调整。</li>
</ul>
<p>四种结构：</p>
<ul>
<li>顺序存储结构</li>
<li>链式存储结构</li>
<li>索引存储结构</li>
<li>散列存储结构</li>
</ul>
<h3 id="3-2-数据类型">3.2 数据类型</h3>
<h4 id="3-2-1-基础数据类型">3.2.1 基础数据类型</h4>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用多种基本数据类型来初始化数组</span></span><br><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>];</span><br><span class="line"><span class="type">float</span> decimals[<span class="number">5</span>];</span><br><span class="line"><span class="type">char</span> characters[<span class="number">5</span>];</span><br><span class="line"><span class="type">bool</span> bools[<span class="number">5</span>];</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-2-2-抽象数据类型">3.2.2 抽象数据类型</h4>

                    </div>
                </div>
            </div>

            <div style="text-align: right;">
                <button type="button" class="read-more">
                    <a href="/2024/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E7%BB%AA%E8%AE%BA/">阅读更多</a>
                </button>
            </div>
        
            
            
                <hr>
            
            <div class="article-item"> 
                <div class="article-item-title">
                    <h1>
                        <a href="/2024/01/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%880%EF%BC%89%E5%8A%A0%E6%B2%B9%EF%BC%81/">
                            数据结构与算法学习笔记（0）加油！
                        </a>
                    </h1>
                    <div class="info">
                        
                        
                            <span>
                                2024/01/09
                            </span>
                        
                    </div>
                </div>
                <div class="article-item-excerpt article">
                    <div>
                        <p>参考资料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nJ411V7bd?p=1&amp;vd_source=214d72bf7806b141a53a9df39a43a75a">B站青岛大学网课</a></li>
<li><a target="_blank" rel="noopener" href="https://www.hello-algo.com/">Hello算法电子书</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/IRVING-L/Algorithm_fromBilibili">某同学的github项目</a></li>
</ol>
<p>种一棵树，最好的时间是十年前，其次是现在。冲冲冲！</p>

                    </div>
                </div>
            </div>

            <div style="text-align: right;">
                <button type="button" class="read-more">
                    <a href="/2024/01/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%880%EF%BC%89%E5%8A%A0%E6%B2%B9%EF%BC%81/">阅读更多</a>
                </button>
            </div>
        
            
            
                <hr>
            
            <div class="article-item"> 
                <div class="article-item-title">
                    <h1>
                        <a href="/2024/01/09/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8813%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/">
                            C++学习笔记（13）运算符重载
                        </a>
                    </h1>
                    <div class="info">
                        
                        
                            <span>
                                2024/01/09
                            </span>
                        
                    </div>
                </div>
                <div class="article-item-excerpt article">
                    <div>
                        <h2 id="一、运算符重载基础">一、运算符重载基础</h2>
<p>C++将运算符重载扩展到自定义的数据类型，它可以让对象操作更美观。<br>
例如字符串string用加号（+）拼接、cout用两个左尖括号（&lt;&lt;）输出。<br>
运算符重载函数的语法：<code>返回值 operator运算符(参数列表);</code><br>
<strong>运算符重载函数的返回值类型要与运算符本身的含义一致。</strong><br>
非成员函数版本的重载运算符函数：形参个数与运算符的操作数个数相同；<br>
成员函数版本的重载运算符函数：形参个数比运算符的操作数个数少一个，其中的一个操作数隐式传递了调用对象。<br>
如果同时重载了非成员函数和成员函数版本，会出现二义性。<br>
注意：<br>
1）返回自定义数据类型的引用可以让多个运算符表达式串联起来。（不要返回局部变量的引用）<br>
2）重载函数参数列表中的顺序决定了操作数的位置。<br>
3）重载函数的参数列表中至少有一个是用户自定义的类型，防止程序员为内置数据类型重载运算符。<br>
4）如果运算符重载既可以是成员函数也可以是全局函数，应该优先考虑成员函数，这样更符合运算符重载的初衷。<br>
5）重载函数不能违背运算符原来的含义和优先级。<br>
6）不能创建新的运算符。<br>
7）以下运算符不可重载：<br>
	sizeof             sizeof运算符<br>
	.                  成员运算符<br>
	.*                 成员指针运算符<br>
	::                 作用域解析运算符<br>
	?:                 条件运算符<br>
	typeid            一个RTTI运算符<br>
	const_cast        强制类型转换运算符<br>
	dynamic_cast     强制类型转换运算符<br>
	reinterpret_cast   强制类型转换运算符<br>
	static_cast        强制类型转换运算符<br>
8）以下运算符只能通过成员函数进行重载：<br>
	=                赋值运算符<br>
	()                函数调用运算符<br>
	[]                下标运算符<br>
	-&gt;               通过指针访问类成员的运算符<br>
示例：<br>
#include <iostream>         // 包含头文件。<br>
using namespace std;        // 指定缺省的命名空间。</iostream></p>
<p>class CGirl       // 超女类CGirl。<br>
{<br>
friend CGirl &amp;operator+(CGirl&amp; g, int score);<br>
friend CGirl&amp; operator+(int score, CGirl&amp; g);<br>
friend CGirl&amp; operator+(CGirl&amp; g1, CGirl&amp; g2);<br>
private:<br>
int         m_xw;        // 胸围。<br>
int         m_score;    // 分数。<br>
public:<br>
string    m_name;   // 姓名。</p>
<pre><code>// 默认构造函数。
CGirl() { m_name = "西施";  m_xw = 87;  m_score = 30; }
// 自我介绍的方法。
void show() { cout &lt;&lt; "姓名：" &lt;&lt; m_name &lt;&lt; "，胸围：" &lt;&lt; m_xw &lt;&lt; "，评分：" &lt;&lt; m_score &lt;&lt; endl; }

//CGirl&amp; operator-(int score)    // 给超女减分的函数。
//{
//    m_score = m_score - score;
//    return *this;
//}
</code></pre>
<p>};</p>
<p>CGirl&amp; operator+(CGirl&amp; g, int score)    // 给超女加分的函数。<br>
{<br>
g.m_score = g.m_score + score;<br>
return g;<br>
}<br>
CGirl&amp; operator+(int score,CGirl&amp; g)    // 给超女加分的函数。<br>
{<br>
g.m_score = g.m_score + score;<br>
return g;<br>
}<br>
CGirl&amp; operator+(CGirl&amp; g1, CGirl&amp; g2)    // 给超女加分的函数。<br>
{<br>
g1.m_score = g1.m_score + g2.m_score;<br>
return g1;<br>
}</p>
<p>int main()<br>
{<br>
// 导演的要求：每轮表演之后，给超女加上她的得分。<br>
CGirl g;<br>
g =  g+g;<br>
g.show();<br>
}</p>
<h2 id="重载关系运算符">重载关系运算符</h2>
<p>重载关系运算符（==、!=、&gt;、&gt;=、&lt;、&lt;=）用于比较两个自定义数据类型的大小。<br>
可以使用非成员函数和成员函数两种版本，建议采用成员函数版本。<br>
示例：<br>
#include <iostream>         // 包含头文件。<br>
using namespace std;        // 指定缺省的命名空间。</iostream></p>
<p>class CGirl       // 超女类CGirl。<br>
{<br>
string    m_name;     // 姓名。<br>
int         m_yz;           // 颜值：1-千年美人；2-百年美人；3-绝代美人；4-极漂亮；5-漂亮；6-一般；7-歪瓜裂枣。<br>
int         m_sc;           // 身材：1-火辣；2-…；3-…；4-…；5-…；6-…；7-膘肥体壮。<br>
int         m_acting;    // 演技：1-完美；2-…；3-…；4-…；5-…；6-…；7-四不像。<br>
public:<br>
// 四个参数的构造函数。<br>
CGirl(string name, int yz, int sc, int acting) { m_name = name;  m_yz = yz;  m_sc = sc; m_acting = acting; }<br>
// 比较两个超女的商业价值。<br>
bool operator==(const CGirl&amp; g1)      // 相等==<br>
{<br>
if ((m_yz + m_sc + m_acting) == (g1.m_yz + g1.m_sc + g1.m_acting)) return true;<br>
return false;<br>
}<br>
bool operator&gt;(const CGirl&amp; g1)      // 大于&gt;<br>
{<br>
if ((m_yz + m_sc + m_acting) &lt; (g1.m_yz + g1.m_sc + g1.m_acting)) return true;<br>
return false;<br>
}<br>
bool operator&lt;(const CGirl&amp; g1)      // 小于&lt;<br>
{<br>
if ((m_yz + m_sc + m_acting) &gt; (g1.m_yz + g1.m_sc + g1.m_acting)) return true;<br>
return false;<br>
}<br>
};</p>
<p>int main()<br>
{<br>
CGirl  g1(“西施”, 1, 2, 2), g2(“冰冰”, 1, 1, 1);</p>
<pre><code>if (g1==g2)
    cout &lt;&lt; "西施和冰冰的商业价值相同。\n";
else
    if (g1&gt;g2)
        cout &lt;&lt; "西施商业价值相同比冰冰大。\n";
    else
        cout &lt;&lt; "冰冰商业价值相同比西施大。\n";
</code></pre>
<p>}</p>
<h2 id="重载左移运算符">重载左移运算符</h2>
<p>重载左移运算符（&lt;&lt;）用于输出自定义对象的成员变量，在实际开发中很有价值（调试和日志）。<br>
只能使用非成员函数版本。<br>
如果要输出对象的私有成员，可以配合友元一起使用。<br>
示例：<br>
#include <iostream>         // 包含头文件。<br>
using namespace std;        // 指定缺省的命名空间。</iostream></p>
<p>class CGirl       // 超女类CGirl。<br>
{<br>
friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, const CGirl&amp; g);<br>
string    m_name;   // 姓名。<br>
int         m_xw;        // 胸围。<br>
int         m_score;    // 评分。<br>
public:<br>
// 默认构造函数。<br>
CGirl() { m_name = “西施”;  m_xw = 87;  m_score = 30; }</p>
<pre><code>// 自我介绍的方法。
void show() { cout &lt;&lt; "姓名：" &lt;&lt; m_name &lt;&lt; "，胸围：" &lt;&lt; m_xw &lt;&lt; "，评分：" &lt;&lt; m_score &lt;&lt; endl; }
</code></pre>
<p>};</p>
<p>ostream&amp; operator&lt;&lt;(ostream&amp; cout, const CGirl&amp; g)<br>
{<br>
cout &lt;&lt; “姓名：” &lt;&lt; g.m_name &lt;&lt; “，胸围：” &lt;&lt; g.m_xw &lt;&lt; “，评分：” &lt;&lt; g.m_score;<br>
return cout;<br>
}</p>
<p>int main()<br>
{<br>
CGirl g;<br>
cout &lt;&lt; g &lt;&lt; endl;<br>
}</p>
<h2 id="重载下标运算符">重载下标运算符</h2>
<p>如果对象中有数组，重载下标运算符[]，操作对象中的数组将像操作普通数组一样方便。<br>
下标运算符必须以成员函数的形式进行重载。<br>
下标运算符重载函数的语法：<br>
返回值类型 &amp;perator<a href="%E5%8F%82%E6%95%B0"></a>;<br>
或者：<br>
const 返回值类型 &amp;operator<a href="%E5%8F%82%E6%95%B0"></a> const;<br>
使用第一种声明方式，[]不仅可以访问数组元素，还可以修改数组元素。<br>
使用第二种声明方式，[]只能访问而不能修改数组元素。<br>
在实际开发中，我们应该同时提供以上两种形式，这样做是为了适应const对象，因为通过const 对象只能调用const成员函数，如果不提供第二种形式，那么将无法访问const对象的任何数组元素。<br>
在重载函数中，可以对下标做合法性检查，防止数组越界。</p>
<p>例：<br>
#include <iostream>         // 包含头文件。<br>
using namespace std;        // 指定缺省的命名空间。</iostream></p>
<p>class CGirl       // 超女类CGirl。<br>
{<br>
private:<br>
string    m_boys[3];       // 超女的男朋友<br>
public:<br>
string    m_name;          // 姓名。</p>
<pre><code>// 默认构造函数。
CGirl() { m_boys[0] = "子都"; m_boys[1] = "潘安"; m_boys[2] = "宋玉"; }
// 显示全部男朋友的姓名。
void show() { cout &lt;&lt; m_boys[0] &lt;&lt; "、" &lt;&lt; m_boys[1] &lt;&lt; "、" &lt;&lt; m_boys[2] &lt;&lt; endl; }
string&amp; operator[](int ii)
{
    return m_boys[ii];
}
const string&amp; operator[](int ii) const
{
    return m_boys[ii];
}
</code></pre>
<p>};</p>
<p>int main()<br>
{<br>
CGirl g;          // 创建超女对象。<br>
g[1] = “王麻子”;<br>
cout &lt;&lt; “第1任男朋友：” &lt;&lt; g[1] &lt;&lt; endl;<br>
g.show();</p>
<pre><code>const CGirl g1 = g;
cout &lt;&lt; "第1任男朋友：" &lt;&lt; g1[1] &lt;&lt; endl;
</code></pre>
<p>}</p>
<h2 id="重载赋值运算符">重载赋值运算符</h2>
<p>C++编译器可能会给类添加四个函数：<br>
	默认构造函数，空实现。<br>
	默认析构函数，空实现。<br>
	默认拷贝构造函数，对成员变量进行浅拷贝。<br>
	默认赋值函数, 对成员变量进行浅拷贝。<br>
对象的赋值运算是用一个已经存在的对象，给另一个已经存在的对象赋值。<br>
如果类的定义中没有重载赋值函数，编译器就会提供一个默认赋值函数。<br>
如果类中重载了赋值函数，编译器将不提供默认赋值函数。<br>
重载赋值函数的语法：类名 &amp; operator=(const 类名 &amp; 源对象);<br>
注意：<br>
	编译器提供的默认赋值函数，是浅拷贝。<br>
	如果对象中不存在堆区内存空间，默认赋值函数可以满足需求，否则需要深拷贝。<br>
	赋值运算和拷贝构造不同：拷贝构造是指原来的对象不存在，用已存在的对象进行构造；赋值运算是指已经存在了两个对象，把其中一个对象的成员变量的值赋给另一个对象的成员变量。<br>
示例：<br>
#include <iostream>         // 包含头文件。<br>
using namespace std;        // 指定缺省的命名空间。</iostream></p>
<p>class CGirl       // 超女类CGirl。<br>
{<br>
public:<br>
int         m_bh;               // 编号。<br>
string    m_name;          // 姓名。<br>
int*        m_ptr;              // 计划使用堆区内存。</p>
<pre><code>CGirl() { m_ptr = nullptr; }
~CGirl() { if (m_ptr)  delete m_ptr;  }
// 显示全部成员变量。
void show() { cout &lt;&lt; "编号：" &lt;&lt; m_bh &lt;&lt; "，姓名：" &lt;&lt; m_name &lt;&lt; "，m_ptr=" &lt;&lt; m_ptr &lt;&lt;/* "，*m_ptr=" &lt;&lt; *m_ptr&lt;&lt; */endl; }
CGirl&amp; operator=(const CGirl&amp; g)
{
    if (this == &amp;g) return *this;          // 如果是自己给自己赋值。
    
    if (g.m_ptr == nullptr)    // 如果源对象的指针为空，则清空目标对象的内存和指针。
    {
        if (m_ptr != nullptr) { delete m_ptr; m_ptr = nullptr; }
    }
    else    // 如果源对象的指针不为空。
    {
        // 如果目标对象的指针为空，先分配内存。
        if (m_ptr == nullptr) m_ptr = new int;
        // 然后，把源对象内存中的数据复制到目标对象的内存中。
        memcpy(m_ptr, g.m_ptr, sizeof(int));
    }
              
    m_bh = g.m_bh; m_name = g.m_name;
    cout &lt;&lt; "调用了重载赋值函数。\n" &lt;&lt; endl; 
    return *this;
}
</code></pre>
<p>};</p>
<p>int main()<br>
{<br>
CGirl g1, g2;          // 创建超女对象。<br>
g1.m_bh = 8; g1.m_name = “西施”; g1.m_ptr = new int(3);<br>
g1.show();<br>
g2.show();</p>
<pre><code>g2 = g1;  
g2.show(); 
cout &lt;&lt; "*g1.m_ptr=" &lt;&lt; *g1.m_ptr &lt;&lt; "，*g2.m_ptr=" &lt;&lt; *g2.m_ptr &lt;&lt; endl;
</code></pre>
<p>}</p>
<h2 id="重载new-delete运算符">重载new&amp;delete运算符</h2>
<p>重载new和delete运算符的目是为了自定义内存分配的细节。（内存池：快速分配和归还，无碎片）<br>
建议先学习C语言的内存管理函数malloc()和free()。<br>
在C++中，使用new时，编译器做了两件事情：<br>
1）调用标准库函数operator new()分配内存；<br>
2）调用构造函数初始化内存；<br>
使用delete时，也做了两件事情：<br>
1）调用析构函数；<br>
2）调用标准库函数operator delete()释放内存。<br>
构造函数和析构函数由编译器调用，我们无法控制。<br>
但是，可以重载内存分配函数operator new()和释放函数operator delete()。<br>
1）重载内存分配函数的语法：void* operator new(size_t size);<br>
参数必须是size_t，返回值必须是void*。<br>
2）重载内存释放函数的语法：void operator delete(void* ptr)<br>
参数必须是void *（指向由operator new()分配的内存），返回值必须是void。<br>
重载的new和delete可以是全局函数，也可以是类的成员函数。<br>
为一个类重载new和delete时，尽管不必显式地使用static，但实际上仍在创建static成员函数。<br>
编译器看到使用new创建自定义的类的对象时，它选择成员版本的operator new()而不是全局版本的new()。<br>
new[]和delete[]也可以重载。<br>
示例：<br>
#include <iostream>         // 包含头文件。<br>
using namespace std;        // 指定缺省的命名空间。</iostream></p>
<p>void* operator new(size_t size)   // 参数必须是size_t（unsigned long long），返回值必须是void*。<br>
{<br>
cout &lt;&lt; “调用了全局重载的new：” &lt;&lt; size &lt;&lt; “字节。\n”;<br>
void* ptr = malloc(size);        // 申请内存。<br>
cout &lt;&lt; “申请到的内存的地址是：” &lt;&lt; ptr &lt;&lt; endl;<br>
return ptr;<br>
}</p>
<p>void operator delete(void* ptr)   // 参数必须是void *，返回值必须是void。<br>
{<br>
cout &lt;&lt; “调用了全局重载的delete。\n”;<br>
if (ptr == 0) return;       // 对空指针delete是安全的。<br>
free(ptr);      // 释放内存。<br>
}</p>
<p>class CGirl       // 超女类CGirl。<br>
{<br>
public:<br>
int        m_bh;               // 编号。<br>
int        m_xw;               // 胸围。</p>
<pre><code>CGirl(int bh, int xw) { m_bh = bh, m_xw = xw;  cout &lt;&lt; "调用了构造函数CGirl()\n"; }
~CGirl() { cout &lt;&lt; "调用了析构函数~CGirl()\n"; }
void* operator new(size_t size)   // 参数必须是size_t（unsigned long long），返回值必须是void*。
{
	cout &lt;&lt; "调用了类的重载的new：" &lt;&lt; size &lt;&lt; "字节。\n";
	void* ptr = malloc(size);        // 申请内存。
	cout &lt;&lt; "申请到的内存的地址是：" &lt;&lt; ptr &lt;&lt; endl;
	return ptr;
}
     
void operator delete(void* ptr)   // 参数必须是void *，返回值必须是void。
{
	cout &lt;&lt; "调用了类的重载的delete。\n";
	if (ptr == 0) return;       // 对空指针delete是安全的。
	free(ptr);      // 释放内存。
}
</code></pre>
<p>};</p>
<p>int main()<br>
{<br>
int* p1 = new int(3);<br>
cout &lt;&lt; “p1=” &lt;&lt; (void *)p1 &lt;&lt;“，*p1=” &lt;&lt;*p1&lt;&lt; endl;<br>
delete p1;</p>
<pre><code>CGirl* p2 = new CGirl(3, 8);
cout &lt;&lt; "p2的地址是：" &lt;&lt; p2 &lt;&lt; "编号：" &lt;&lt; p2-&gt;m_bh &lt;&lt; "，胸围：" &lt;&lt; p2-&gt;m_xw &lt;&lt; endl;
delete p2;
</code></pre>
<p>}<br>
内存池示例：<br>
#include <iostream>         // 包含头文件。<br>
using namespace std;        // 指定缺省的命名空间。</iostream></p>
<p>class CGirl       // 超女类CGirl。<br>
{<br>
public:<br>
int        m_bh;               // 编号。<br>
int        m_xw;               // 胸围。<br>
static char*    m_pool;           // 内存池的起始地址。</p>
<pre><code>static bool initpool()             // 个初始化内存池的函数。
{
	m_pool = (char*)malloc(18);           // 向系统申请18字节的内存。
	if (m_pool == 0)  return false;        // 如果申请内存失败，返回false。
	memset(m_pool, 0, 18);                  // 把内存池中的内容初始化为0。
	cout &lt;&lt; "内存池的起始地址是：" &lt;&lt; (void*)m_pool &lt;&lt; endl;
	return true;
}
           
static void freepool()                                     // 释放内存池。
{
	if (m_pool == 0) return;                  // 如果内存池为空，不需要释放，直接返回。
	free(m_pool);                                        // 把内存池归还给系统。
	cout &lt;&lt; "内存池已释放。\n";
}
           
CGirl(int bh, int xw) { m_bh = bh, m_xw = xw;  cout &lt;&lt; "调用了构造函数CGirl()\n"; }
~CGirl() { cout &lt;&lt; "调用了析构函数~CGirl()\n"; }
         
void* operator new(size_t size)   // 参数必须是size_t（unsigned long long），返回值必须是void*。
{
	if (m_pool[0] == 0)      // 判断第一个位置是否空闲。
	{
		cout &lt;&lt; "分配了第一块内存：" &lt;&lt; (void*)(m_pool + 1) &lt;&lt; endl;
		m_pool[0] = 1;         // 把第一个位置标记为已分配。
		return m_pool + 1;  // 返回第一个用于存放对象的址。
	}
	if (m_pool[9] == 0)          // 判断第二个位置是否空闲。
	{
		cout &lt;&lt; "分配了第二块内存：" &lt;&lt; (void*)(m_pool + 9) &lt;&lt; endl;
		m_pool[9] = 1;             // 把第二个位置标记为已分配。
		return m_pool + 9;      // 返回第二个用于存放对象的址。
	}
	
	// 如果以上两个位置都不可用，那就直接系统申请内存。
	void* ptr = malloc(size);        // 申请内存。
	cout &lt;&lt; "申请到的内存的地址是：" &lt;&lt; ptr &lt;&lt; endl;
	return ptr;
}
          
void operator delete(void* ptr)   // 参数必须是void *，返回值必须是void。
{
	if (ptr == 0) return;      // 如果传进来的地址为空，直接返回。
            
	if (ptr == m_pool + 1)      // 如果传进来的地址是内存池的第一个位置。
	{
		cout &lt;&lt; "释放了第一块内存。\n";
		m_pool[0] = 0;              // 把第一个位置标记为空闲。
		return;
	}
            
	if (ptr == m_pool + 9)      // 如果传进来的地址是内存池的第二个位置。
	{
		cout &lt;&lt; "释放了第二块内存。\n";
		m_pool[9] = 0;              // 把第二个位置标记为空闲。
		return;
	}
             
	// 如果传进来的地址不属于内存池，把它归还给系统。
	free(ptr);      // 释放内存。
}
</code></pre>
<p>};</p>
<p>char* CGirl::m_pool = 0;       // 初始化内存池的指针。</p>
<p>int main()<br>
{<br>
// 初始化内存池。<br>
if (CGirl::initpool()==false) { cout &lt;&lt; “初始化内存池失败。\n”; return -1; }</p>
<pre><code>CGirl* p1 = new CGirl(3, 8);       // 将使用内存池的第一个位置。
cout &lt;&lt; "p1的地址是：" &lt;&lt; p1 &lt;&lt; "，编号：" &lt;&lt; p1-&gt;m_bh &lt;&lt; "，胸围：" &lt;&lt; p1-&gt;m_xw &lt;&lt; endl;
              
CGirl* p2 = new CGirl(4, 7);       // 将使用内存池的第二个位置。
cout &lt;&lt; "p2的地址是：" &lt;&lt; p2 &lt;&lt; "，编号：" &lt;&lt; p2-&gt;m_bh &lt;&lt; "，胸围：" &lt;&lt; p2-&gt;m_xw &lt;&lt; endl;
                
CGirl* p3 = new CGirl(6, 9);       // 将使用系统的内存。
cout &lt;&lt; "p3的地址是：" &lt;&lt; p3 &lt;&lt; "，编号：" &lt;&lt; p3-&gt;m_bh &lt;&lt; "，胸围：" &lt;&lt; p3-&gt;m_xw &lt;&lt; endl;
             
delete p1;    // 将释放内存池的第一个位置。
             
CGirl* p4 = new CGirl(5, 3);        // 将使用内存池的第一个位置。
cout &lt;&lt; "p4的地址是：" &lt;&lt; p4 &lt;&lt; "，编号：" &lt;&lt; p4-&gt;m_bh &lt;&lt; "，胸围：" &lt;&lt; p4-&gt;m_xw &lt;&lt; endl;
    
delete p2;    // 将释放内存池的第二个位置。
delete p3;    // 将释放系统的内存。
delete p4;    // 将释放内存池的第一个位置。
            
CGirl::freepool();     // 释放内存池。
</code></pre>
<p>}</p>
<h2 id="重载括号运算符">重载括号运算符</h2>
<p>括号运算符()也可以重载，对象名可以当成函数来使用（函数对象、仿函数）。<br>
括号运算符重载函数的语法：<br>
返回值类型 operator()(参数列表);<br>
注意：<br>
	括号运算符必须以成员函数的形式进行重载。<br>
	括号运算符重载函数具备普通函数全部的特征。<br>
	如果函数对象与全局函数同名，按作用域规则选择调用的函数。<br>
函数对象的用途：<br>
1）表面像函数，部分场景中可以代替函数，在STL中得到广泛的应用；<br>
2）函数对象本质是类，可以用成员变量存放更多的信息；<br>
3）函数对象有自己的数据类型；<br>
4）可以提供继承体系。</p>
<p>示例：<br>
#include <iostream>         // 包含头文件。<br>
using namespace std;        // 指定缺省的命名空间。</iostream></p>
<p>void show(string str)    // 向超女表白的函数。<br>
{<br>
cout &lt;&lt; “普通函数：” &lt;&lt; str &lt;&lt; endl;<br>
}</p>
<p>class CGirl      // 超女类。<br>
{<br>
public:<br>
void operator()(string str)    // 向超女表白的函数。<br>
{<br>
cout &lt;&lt; “重载函数：” &lt;&lt; str &lt;&lt; endl;<br>
}<br>
};</p>
<p>int main()<br>
{<br>
CGirl show;<br>
::show(“我是一只傻傻鸟。”);<br>
show(“我是一只傻傻鸟。”);<br>
}</p>
<h2 id="重载一元运算符">重载一元运算符</h2>
<p>可重载的一元运算符。<br>
1）++ 自增       2）-- 自减    3）! 逻辑非     4）&amp; 取地址<br>
5）~ 二进制反码  6）* 解引用   7）+ 一元加    8） - 一元求反<br>
一元运算符通常出现在它们所操作的对象的左边。<br>
但是，自增运算符<ins>和自减运算符–有前置和后置之分。<br>
C</ins> 规定，重载<ins>或–时，如果重载函数有一个int形参，编译器处理后置表达式时将调用这个重载函数。<br>
成员函数版：CGirl &amp;operator</ins>();             // <ins>前置<br>
成员函数版：CGirl operator</ins>(int);            // 后置++<br>
非成员函数版：CGirl &amp;operator++(CGirl &amp;);   // <ins>前置<br>
非成员函数版：CGirl operator</ins>(CGirl &amp;,int);  // 后置++<br>
示例：<br>
#include <iostream>         // 包含头文件。<br>
using namespace std;        // 指定缺省的命名空间。</iostream></p>
<p>class CGirl       // 超女类CGirl。<br>
{<br>
public:<br>
string    m_name;     // 姓名。<br>
int         m_ranking;  // 排名。</p>
<pre><code>// 默认构造函数。
CGirl() { m_name = "西施";  m_ranking = 5; }
// 自我介绍的方法。
void show() const { cout &lt;&lt; "姓名：" &lt;&lt; m_name &lt;&lt; "，排名：" &lt;&lt; m_ranking &lt;&lt; endl; }
CGirl &amp; operator++()         // ++前置的重载函数。
{
    m_ranking++; return *this;
}
CGirl operator++(int)     // ++后置的重载函数。
{
    CGirl tmp = *this;
    m_ranking++; 
    return tmp;
}
</code></pre>
<p>};</p>
<p>int main()<br>
{<br>
CGirl g1,g2;        // 创建超女对象。<br>
int ii=5 , jj=5;<br>
int xx = <ins>(</ins>(<ins>ii));        cout &lt;&lt; “xx=” &lt;&lt; xx &lt;&lt; “,ii=” &lt;&lt; ii &lt;&lt; endl;<br>
int yy = jj</ins>;                       cout &lt;&lt; “yy=” &lt;&lt; yy &lt;&lt; “,jj=” &lt;&lt; jj &lt;&lt; endl;<br>
CGirl g3 = <ins>(</ins>(<ins>g1));   cout &lt;&lt; “g3.m_ranking=” &lt;&lt; g3.m_ranking &lt;&lt; “,g1.m_ranking=” &lt;&lt; g1.m_ranking &lt;&lt; endl;<br>
CGirl g4 = g2</ins>;                   cout &lt;&lt; “g4.m_ranking=” &lt;&lt; g4.m_ranking &lt;&lt; “,g2.m_ranking=” &lt;&lt; g2.m_ranking &lt;&lt; endl;<br>
// g2.show();<br>
}</p>

                    </div>
                </div>
            </div>

            <div style="text-align: right;">
                <button type="button" class="read-more">
                    <a href="/2024/01/09/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8813%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/">阅读更多</a>
                </button>
            </div>
        
            
            
                <hr>
            
            <div class="article-item"> 
                <div class="article-item-title">
                    <h1>
                        <a href="/2024/01/08/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/">
                            C++学习笔记（12）类与对象
                        </a>
                    </h1>
                    <div class="info">
                        
                        
                            <span>
                                2024/01/08
                            </span>
                        
                    </div>
                </div>
                <div class="article-item-excerpt article">
                    <div>
                        <h2 id="一、面向对象编成-对象和类">一、面向对象编成-对象和类</h2>
<ul>
<li>抽象</li>
<li>封装和数据隐藏</li>
<li>多台</li>
<li>继承</li>
<li>代码重用</li>
</ul>
<p><u><em><strong>没有对象？学C++可以直接创建一百个！</strong></em></u></p>
<h2 id="二、从结构体到类">二、从结构体到类</h2>
<p>结构体里面加上<strong>成员函数</strong>，就变成了<strong>类</strong>。<br>
对面向对象编程来说，<u>一切都是对象</u>，对象用类来描述。<br>
==类把对象的数据和操作数据的方法作为一个整体考虑。==</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">定义类的语法：</span><br><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">成员一的数据类型  成员名一;</span><br><span class="line">成员二的数据类型  成员名二;</span><br><span class="line">成员三的数据类型  成员名三;</span><br><span class="line">......</span><br><span class="line">成员n的数据类型  成员名n;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>注意：</p>
<ul>
<li>类的成员可以是<strong>变量</strong>，也可以是*函数**。</li>
<li>类的<strong>成员变量</strong>也叫<strong>属性</strong>。</li>
<li>类的<strong>成员函数</strong>也叫<strong>方法/行为</strong>，类的成员函数<u>可以定义在类的外面</u>。</li>
<li>用类定义一个类的变量叫创建（或实例化）一个对象。</li>
<li>对象的成员变量和成员函数的作用域和生命周期与对象的作用域和生命周期相同。</li>
</ul>
<p>例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>                 <span class="comment">// 超女类CGirl。</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    name;          <span class="comment">// 姓名。</span></span><br><span class="line">    <span class="type">int</span>         age;             <span class="comment">// 年龄。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setvalue</span><span class="params">(string name1, <span class="type">int</span> age1)</span></span>;    <span class="comment">// 设置成员变量的值。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span>    <span class="comment">// 显示超女的自我介绍。</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; name &lt;&lt; <span class="string">"，年龄："</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CGirl::setvalue</span><span class="params">(string name1, <span class="type">int</span> age1)</span>    <span class="comment">// 设置成员变量的值。</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    name = name1;     age = age1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    CGirl girl;       <span class="comment">// 创建超女对象。</span></span><br><span class="line">    girl.<span class="built_in">setvalue</span>(<span class="string">"西施"</span>, <span class="number">26</span>);     <span class="comment">// 设置成员变量的值。</span></span><br><span class="line">    girl.<span class="built_in">show</span>();    <span class="comment">// 显示超女的自我介绍。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="三、类的访问权限">三、类的访问权限</h2>
<p>类的成员有三种访问权限：<code>public</code>、<code>private</code>和<code>protected</code>，分别表示公有的、私有的和受保护的。</p>
<ul>
<li>在类的内部（类的成员函数中），无论成员被声明为 public还是private，都可以访问。</li>
<li><u>在类的<strong>外部</strong>（定义类的代码之外），<strong>只能访问public成员</strong>，不能访问 private、protected成员。</u></li>
<li>在一个类体的定义中，private 和 public 可以出现多次。</li>
<li>结构体的成员缺省为public，<strong>类的成员缺省为private</strong>。</li>
<li>private的意义在于<strong>隐藏类的数据和实现</strong>，把需要向外暴露的成员声明为public。</li>
</ul>
<h2 id="四、简单使用类">四、简单使用类</h2>
<ol>
<li>类的成员函数可以直接访问该类其它的成员函数（可以<strong>递归</strong>）。</li>
<li>类的成员函数可以<strong>重载</strong>，可以使用默认参数。</li>
<li>类指针的用法与结构体指针用法相同。</li>
<li>类的成员可以是任意数据类型（类中枚举）。</li>
<li>可以为类的成员指定缺省值（C++11标准）。</li>
<li>类可以创建<strong>对象数组</strong>，就像结构体数组一样。</li>
<li>对象可以作为实参传递给函数，一般传<strong>引用</strong>。</li>
<li>可以用<code>new</code>动态创建对象，用<code>delete</code>释放对象。</li>
<li>在类的外部，一般不直接访问（读和写）对象的成员，而是用成员函数。==数据隐藏是面向对象编程的思想之一==。</li>
<li>对象一般不用<code>memset()</code>清空成员变量，可以写一个专用于清空成员变量的成员函数。</li>
<li>对类和对象用<code>sizeof</code>运算意义不大，一般不用。</li>
<li>用结构体描述纯粹的数据，用类描述对象。</li>
<li>在类的声明中定义的函数都将自动成为<strong>内联函数</strong>；在类的声明之外定义的函数如果使用了<code>inline</code>限定符，也是内联函数。</li>
<li>为了区分类的成员变量和成员函数的形参，把成员变量名加m_前缀或_后缀，如m_name或name_。</li>
<li>类的分文件编写。</li>
</ol>
<h2 id="五、构造函数和析构函数">五、构造函数和析构函数</h2>
<ul>
<li><strong>构造函数</strong>：在创建对象时，自动的进行初始化工作。</li>
<li><strong>析构函数</strong>：在销毁对象前，自动的完成清理工作。</li>
</ul>
<h3 id="构造函数">构造函数</h3>
<p>语法：<code>类名(){......}</code></p>
<ul>
<li>访问权限必须是<code>public</code>。</li>
<li><strong>函数名必须与类名相同</strong>。</li>
<li><strong>没有返回值，不写void</strong>。</li>
<li>可以有参数，可以重载，可以有默认参数。</li>
<li>创建对象时只会自动调用一次，<strong>不能手工调用</strong>。</li>
</ul>
<h3 id="析构函数">析构函数</h3>
<p>语法：<code>~类名(){......}</code></p>
<ul>
<li>访问权限必须是<code>public</code>。</li>
<li>没有返回值，也不写void。</li>
<li>没有参数，不能重载。</li>
<li>销毁对象前只会<strong>自动调用一次</strong>，但是<strong>可以手工调用</strong>。</li>
</ul>
<h3 id="注意：">注意：</h3>
<ol>
<li>如果没有提供构造/析构函数，编译器将提供空实现的构造/析构函数。</li>
<li>如果提供了构造/析构函数，编译器将不提供空实现的构造/析构函数。</li>
<li>创建对象的时候，如果重载了构造函数，编译器根据实参匹配相应的构造函数。没有参数的构造函数也叫默认构造函数。</li>
<li><u>创建对象的时候不要在对象名后面加空的圆括号，编译器误认为是声明函数。（如果没有构造函数、构造函数没有参数、构造函数的参数都有默认参数）。</u></li>
<li><strong>在构造函数名后面加括号和参数不是调用构造函数，是创建匿名对象。</strong>(<em>如果在构造函数中初始化指针，却没有调用，成为了野指针，析构函数对指针的delete可能会让程序崩溃</em>)</li>
<li>接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值（可能会导致问题，不推荐）。</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGirl girl =<span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure>
<ol start="7">
<li>以下两行代码有本质的区别：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGirl girl = <span class="built_in">CGirl</span>(<span class="string">"西施"</span><span class="number">20</span>);  <span class="comment">// 显式创建对象。</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CGirl girl;                   <span class="comment">// 创建对象。</span></span><br><span class="line">girl = <span class="built_in">CGirl</span>(<span class="string">"西施"</span><span class="number">20</span>);        <span class="comment">// 创建临时对象，然后给现有的对象赋值。一佛嗯</span></span><br></pre></td></tr></tbody></table></figure>
<ol start="8">
<li>用new/delete创建/销毁对象时，也会调用构造/析构函数。</li>
<li>不建议在构造/析构函数中写太多的代码，可以调用成员函数。</li>
<li>除了初始化，不建议让构造函数做太多工作（只能成功不会失败）。</li>
<li>C++11支持使用统一初始化列表。</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGirl girl = {<span class="string">"西施"</span><span class="number">20</span>};</span><br><span class="line">CGirl girl  {<span class="string">"西施"</span><span class="number">20</span>};</span><br><span class="line">CGirl* girl = <span class="keyword">new</span> CGirl{ <span class="string">"西施"</span><span class="number">20</span> };</span><br></pre></td></tr></tbody></table></figure>
<ol start="12">
<li>如果类的成员也是类，创建对象的时候，先构造成员类；销毁对象的时候，先析构自身，再析构成员类（视频中有误）。</li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>                 <span class="comment">// 超女类CGirl。</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;                                  <span class="comment">// 姓名属性。</span></span><br><span class="line">    <span class="type">int</span>         m_age;                                     <span class="comment">// 年龄属性。</span></span><br><span class="line">    <span class="type">char</span>      m_memo[<span class="number">301</span>];                        <span class="comment">// 备注。</span></span><br><span class="line">    <span class="built_in">CGirl</span>()                                        <span class="comment">// 没有参数的构造函数。  </span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">initdata</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"调用了CGirl()构造函数。\n"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">CGirl</span>(string name)                   <span class="comment">// 一个参数（姓名）的构造函数。</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">initdata</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"调用了CGirl(name)构造函数。\n"</span>;</span><br><span class="line">        m_name = name;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">int</span> age)                           <span class="comment">// 一个参数（年龄）的构造函数。</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">initdata</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"调用了CGirl(age)构造函数。\n"</span>;</span><br><span class="line">        m_age = age;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">CGirl</span>(string name, <span class="type">int</span> age)      <span class="comment">// 两个参数的构造函数。</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">initdata</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"调用了CGirl(name,age)构造函数。\n"</span>;</span><br><span class="line">        m_name = name; m_age = age;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initdata</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        m_name.<span class="built_in">clear</span>(); m_age = <span class="number">0</span>; <span class="built_in">memset</span>(m_memo, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_memo));</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">CGirl</span>()                                     <span class="comment">// 析构函数。  </span></span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"调用了~CGirl()\n"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span>                               <span class="comment">// 超女自我介绍的方法。</span></span></span><br><span class="line"><span class="function">    </span>{  cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; <span class="string">"，年龄："</span> &lt;&lt; m_age &lt;&lt; <span class="string">"，备注："</span> &lt;&lt; m_memo&lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// CGirl girl;                     // 创建超女对象，不设置任何初始值。</span></span><br><span class="line">    <span class="comment">// CGirl girl("西施");        // 创建超女对象，为成员姓名设置初始值。  （隐式调用函数）</span></span><br><span class="line">    <span class="comment">// CGirl girl("西施",8);     // 创建超女对象，为成员姓名和年龄设置初始值。</span></span><br><span class="line">    <span class="comment">// CGirl girl=CGirl();                   // 创建超女对象，不设置任何初始值。</span></span><br><span class="line">    <span class="comment">// CGirl girl=CGirl("西施");        // 创建超女对象，为成员姓名设置初始值。  （显式调用函数）</span></span><br><span class="line">    <span class="comment">// CGirl girl=CGirl("西施",8);     // 创建超女对象，为成员姓名和年龄设置初始值。</span></span><br><span class="line">    <span class="comment">// CGirl girl = 8;                         // 使用赋值语法初始化对象。</span></span><br><span class="line">    <span class="comment">// CGirl *girl=new CGirl;                   // 创建超女对象，不设置任何初始值。</span></span><br><span class="line">    <span class="comment">// CGirl *girl=new CGirl("西施");        // 创建超女对象，为成员姓名设置初始值。</span></span><br><span class="line">    CGirl *girl=<span class="keyword">new</span> <span class="built_in">CGirl</span>(<span class="string">"西施"</span>,<span class="number">8</span>);     <span class="comment">// 创建超女对象，为成员姓名和年龄设置初始值。</span></span><br><span class="line">    </span><br><span class="line">    girl-&gt;<span class="built_in">show</span>();    <span class="comment">// 显示超女的自我介绍。</span></span><br><span class="line">    <span class="keyword">delete</span> girl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="六、拷贝构造函数">六、拷贝构造函数</h2>
<p>用一个已存在的对象创建新的对象，<strong>不会调用（普通）构造函数，而是调用拷贝构造函数</strong>。<br>
如果类中没有定义拷贝构造函数，编译器将提供一个拷贝构造函数，它的功能是把已存在对象的成员变量赋值给新对象的成员变量。<br>
用一个已存在的对象创建新的对象语法：<br>
<code>类名 新对象名(已存在的对象名);</code><br>
<code>类名 新对象名=已存在的对象名;</code><br>
<strong>拷贝构造函数</strong>的语法：<br>
<code>类名(const 类名&amp; 对象名){......}</code><br>
注意：</p>
<ul>
<li>访问权限必须是<code>public</code>。</li>
<li>函数名必须与<code>类名</code>相同。</li>
<li>没有返回值，不写void。</li>
<li>如果类中定义了拷贝构造函数，编译器将不提供默认的拷贝构造函数。</li>
<li>以<strong>值传递</strong>的方式<strong>调用函数</strong>时，如果实参为对象，会调用拷贝构造函数。</li>
<li><strong>函数以值的方式返回对象时，可能会调用拷贝构造函数（VS会调用，Linux不会，g++编译器做了优化）</strong>。</li>
<li>拷贝构造函数可以重载，可以有默认参数。<br>
<code>类名(......,const 类名&amp; 对象名,......){......}</code></li>
<li>如果类中重载了拷贝构造函数却没有定义默认的拷贝构造函数，编译器也会提供<strong>默认的拷贝构造函数</strong>。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>                 <span class="comment">// 超女类CGirl。</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;                                  <span class="comment">// 姓名属性。</span></span><br><span class="line">    <span class="type">int</span>         m_age;                                     <span class="comment">// 年龄属性。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有参数的普通构造函数。  </span></span><br><span class="line">    <span class="built_in">CGirl</span>() { m_name.<span class="built_in">clear</span>(); m_age = <span class="number">0</span>;  cout &lt;&lt; <span class="string">"调用了CGirl()构造函数。\n"</span>; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有重载的拷贝构造函数（默认拷贝构造函数）。  </span></span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> CGirl &amp;gg) { m_name=<span class="string">"漂亮的"</span>+gg.m_name; m_age = gg.m_age<span class="number">-1</span>;  cout &lt;&lt; <span class="string">"调用了CGirl(const CGirl &amp;gg)拷贝构造函数。\n"</span>; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载的拷贝构造函数。  </span></span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> CGirl&amp; gg,<span class="type">int</span> ii) { m_name = <span class="string">"漂亮的"</span> + gg.m_name; m_age = gg.m_age - ii;  cout &lt;&lt; <span class="string">"调用了CGirl(const CGirl &amp;gg,int ii)拷贝构造函数。\n"</span>; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数。  </span></span><br><span class="line">    ~<span class="built_in">CGirl</span>() { cout &lt;&lt; <span class="string">"调用了~CGirl()\n"</span>; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超女自我介绍的方法，显示姓名和年龄。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; <span class="string">"，年龄："</span> &lt;&lt; m_age &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    CGirl g1;</span><br><span class="line">    g1.m_name = <span class="string">"西施"</span>; g1.m_age = <span class="number">23</span>;</span><br><span class="line">    <span class="function">CGirl <span class="title">g2</span><span class="params">(g1,<span class="number">3</span>)</span></span>;</span><br><span class="line">    g2.<span class="built_in">show</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>                 <span class="comment">// 超女类CGirl。</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;                                  <span class="comment">// 姓名属性。</span></span><br><span class="line">    <span class="type">int</span>         m_age;                                     <span class="comment">// 年龄属性。</span></span><br><span class="line">    <span class="type">int</span>*       m_ptr;                                       <span class="comment">// 指针成员，计划使用堆内存。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有参数的普通构造函数。  </span></span><br><span class="line">    <span class="built_in">CGirl</span>() { m_name.<span class="built_in">clear</span>(); m_age = <span class="number">0</span>;  m_ptr = <span class="literal">nullptr</span>;  cout &lt;&lt; <span class="string">"调用了CGirl()构造函数。\n"</span>; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有重载的拷贝构造函数（默认拷贝构造函数）。  </span></span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> CGirl&amp; gg) </span><br><span class="line">    { </span><br><span class="line">        m_name = gg.m_name; m_age = gg.m_age;  </span><br><span class="line">        m_ptr = <span class="keyword">new</span> <span class="type">int</span>;         <span class="comment">// 分配内存。</span></span><br><span class="line">        <span class="comment">// *m_ptr = *gg.m_ptr;   // 拷贝数据。</span></span><br><span class="line">        <span class="built_in">memcpy</span>(m_ptr, gg.m_ptr, <span class="built_in">sizeof</span>(<span class="type">int</span>));   <span class="comment">// 拷贝数据。</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"调用了CGirl(const CGirl &amp;gg)拷贝构造函数。\n"</span>; </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数。  </span></span><br><span class="line">    ~<span class="built_in">CGirl</span>() { <span class="keyword">delete</span> m_ptr; m_ptr = <span class="literal">nullptr</span>; cout &lt;&lt; <span class="string">"调用了~CGirl()\n"</span>;  }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超女自我介绍的方法，显示姓名和年龄。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; <span class="string">"，年龄："</span> &lt;&lt; m_age &lt;&lt; <span class="string">"，m_ptr="</span>&lt;&lt; m_ptr&lt;&lt;<span class="string">"，*m_ptr="</span>&lt;&lt;*m_ptr&lt;&lt;endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    CGirl g1;</span><br><span class="line">    g1.m_name = <span class="string">"西施"</span>; g1.m_age = <span class="number">23</span>; g1.m_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line">    g1.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">CGirl <span class="title">g2</span><span class="params">(g1)</span></span>;  *g2.m_ptr = <span class="number">8</span>;</span><br><span class="line">    g1.<span class="built_in">show</span>();</span><br><span class="line">    g2.<span class="built_in">show</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="七、浅拷贝和深拷贝">七、浅拷贝和深拷贝</h2>
<h2 id="八、初始化列表">八、初始化列表</h2>
<p>构造函数的执行可以分成两个阶段：<strong>初始化阶段</strong>和<strong>计算阶段</strong>（初始化阶段先于计算阶段）。</p>
<ul>
<li>初始化阶段：全部的成员都会在初始化阶段初始化。</li>
<li>计算阶段：一般是指用于执行构造函数体内的<strong>赋值</strong>操作。</li>
</ul>
<p>构造函数除了参数列表和函数体之外，还可以有初始化列表。<br>
初始化列表的语法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名(形参列表):成员一(值一), 成员二(值二),..., 成员<span class="built_in">n</span>(值n)</span><br><span class="line">{......}</span><br></pre></td></tr></tbody></table></figure>
<p>注意：</p>
<ol>
<li>如果成员已经在初始化列表中，则不应该在构造函数中再次赋值。</li>
<li>初始化列表的括号中可以是具体的值，<strong>也可以是构造函数的形参名，还可以是表达式</strong>。</li>
<li>==初始化列表与赋值有本质的区别，如果成员是类，使用初始化列表调用的是成员类的拷贝构造函数，而赋值则是先创建成员类的对象（将调用成员类的普通构造函数），然后再赋值。==</li>
<li>如果成员是类，初始化列表<strong>对性能略有提升</strong>。</li>
<li>如果成员是<strong>常量</strong>和<strong>引用</strong>，必须使用初始列表，因为<u>常量和引用只能在定义的时候初始化</u>。</li>
<li>如果成员是没有默认构造函数的类，则必须使用初始化列表。</li>
<li>拷贝构造函数也可以有初始化列表。</li>
<li>类的成员变量可以不出现在初始化列表中。</li>
<li>构造函数的形参先于成员变量初始化。</li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBoy</span>                <span class="comment">// 男朋友类。</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_xm;                      <span class="comment">// 男朋友的姓名。</span></span><br><span class="line">    <span class="built_in">CBoy</span>()                                 <span class="comment">// 没有参数的普通构造函数，默认构造函数。  </span></span><br><span class="line">    { m_xm.<span class="built_in">clear</span>();  cout &lt;&lt; <span class="string">"调用了CBoy()构造函数。\n"</span>; }</span><br><span class="line">    <span class="built_in">CBoy</span>(string xm)                 <span class="comment">// 有一个参数的普通构造函数。  </span></span><br><span class="line">    { m_xm = xm;  cout &lt;&lt; <span class="string">"调用了CBoy(string xm)构造函数。\n"</span>; }</span><br><span class="line">    <span class="built_in">CBoy</span>(<span class="type">const</span> CBoy&amp; bb)     <span class="comment">// 默认拷贝构造函数。  </span></span><br><span class="line">    { m_xm = bb.m_xm;  cout &lt;&lt; <span class="string">"调用了CBoy(const CBoy &amp;bb)拷贝构造函数。\n"</span>; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>                 <span class="comment">// 超女类CGirl。</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;                     <span class="comment">// 姓名属性。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>         m_age;                         <span class="comment">// 年龄属性。</span></span><br><span class="line">    CBoy&amp;     m_boy;                         <span class="comment">// 男朋友的信息。</span></span><br><span class="line">    <span class="comment">//CGirl()                                       // 没有参数的普通构造函数，默认构造函数。  </span></span><br><span class="line">    <span class="comment">//{  </span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; "调用了CGirl()构造函数。\n"; </span></span><br><span class="line">    <span class="comment">//}</span></span><br><span class="line">    <span class="comment">//CGirl(string name, int age,CBoy &amp;boy)     // 三个参数的普通构造函数。</span></span><br><span class="line">    <span class="comment">//{</span></span><br><span class="line">    <span class="comment">//    m_name = name; m_age = age; m_boy.m_xm = boy.m_xm;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; "调用了CGirl(name,age,boy)构造函数。\n";</span></span><br><span class="line">    <span class="comment">//}</span></span><br><span class="line">    <span class="built_in">CGirl</span>(string name, <span class="type">int</span> age, CBoy&amp; boy) :<span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age),<span class="built_in">m_boy</span>(boy)      <span class="comment">// 三个参数的普通构造函数。</span></span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"调用了CGirl(name,age,boy)构造函数。\n"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 超女自我介绍的方法，显示姓名、年龄、男朋友。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; <span class="string">"，年龄："</span> &lt;&lt; m_age &lt;&lt; <span class="string">"，男朋友："</span> &lt;&lt; m_boy.m_xm &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">CBoy <span class="title">boy</span><span class="params">(<span class="string">"子都"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">"冰冰"</span>,<span class="number">18</span>,boy)</span></span>;</span><br><span class="line">    </span><br><span class="line">    g1.<span class="built_in">show</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="九、const修饰成员函数">九、const修饰成员函数</h2>
<p>在类的成员函数后面加<code>const</code>关键字，表示<u><strong>在成员函数中保证不会修改调用对象的成员变量</strong></u>。（编程规范）<br>
<strong>对构造函数和析构函数加<code>const</code>是非法的。</strong><br>
注意：</p>
<ol>
<li><code>mutable</code>可以突破<code>const</code>的限制，被<code>mutable</code>修饰的成员变量，将永远处于可变的状态，在<code>const</code>修饰的函数中，<code>mutable</code>成员也可以被修改。</li>
<li>非<code>const</code>成员函数可以调用<code>const</code>成员函数和非<code>const</code>成员函数。</li>
<li><strong><code>const</code>成员函数不能调用非<code>const</code>成员函数。</strong></li>
<li>非<code>const</code>对象可以调用<code>const</code>修饰的成员函数和非<code>const</code>修饰的成员函数。</li>
<li><strong><code>const</code>对象只能调用<code>const</code>修饰的成员函数，不能调用非<code>cosnt</code>修饰的成员函数。</strong></li>
</ol>
<p>这里出现了令人纠结的三个问题：</p>
<ol>
<li>为什么要保护类的成员变量不被修改？</li>
<li>为什么用const保护了成员变量，还要再定义一个mutable关键字来突破const的封锁线？</li>
<li>到底有没有必要使用const和mutable这两个关键字？</li>
</ol>
<p>保护类的成员变量不在成员函数中被修改，是为了保证模型的逻辑正确，通过用const关键字来避免在函数中错误的修改了类对象的状态。并且在所有使用该成员函数的地方都可以更准确的预测到使用该成员函数的带来的影响。而mutable则是为了能突破const的封锁线，让类的一些次要的或者是辅助性的成员变量随时可以被更改。没有使用const和mutable关键字当然没有错，const和mutable 关键字只是给了建模工具更多的设计约束和设计灵活性，而且程序员也可以把更多的逻辑检查问题交给编译器和建模工具去做，从而减轻程序员的负担。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>                 <span class="comment">// 超女类CGirl。</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">mutable</span> string    m_name;                     <span class="comment">// 姓名属性。</span></span><br><span class="line">    <span class="type">int</span>         m_age;                         <span class="comment">// 年龄属性。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个参数的普通构造函数。</span></span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> string &amp;name, <span class="type">int</span> age) </span><br><span class="line">    { m_name = name; m_age = age;  cout &lt;&lt; <span class="string">"调用了CGirl(name,age)构造函数。\n"</span>; }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 超女自我介绍的方法，显示姓名、年龄。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show1</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{ </span><br><span class="line">        m_name=<span class="string">"西施show1"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; <span class="string">"，年龄："</span> &lt;&lt; m_age &lt;&lt; endl; </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show2</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        m_name = <span class="string">"西施show2"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; <span class="string">"，年龄："</span> &lt;&lt; m_age &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show3</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        m_name = <span class="string">"西施show3"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; <span class="string">"，年龄："</span> &lt;&lt; m_age &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show4</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        m_name = <span class="string">"西施show4"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; <span class="string">"，年龄："</span> &lt;&lt; m_age &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function"><span class="type">const</span> CGirl <span class="title">g1</span><span class="params">(<span class="string">"冰冰"</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    g1.<span class="built_in">show1</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="十、this指针">十、this指针</h2>
<ul>
<li>如果类的成员函数中<strong>涉及多个对象</strong>，在这种情况下需要使用<code>this</code>指针。</li>
<li><u><code>this</code>指针存放了对象的地址，它被作为隐藏参数传递给了成员函数，指向<strong>调用成员函数的对象（调用者对象）</strong>。</u></li>
<li>每个成员函数（包括构造函数和析构函数）都有一个this指针，可以用它访问调用者对象的成员。（可以解决成员变量名与函数形参名相同的问题）</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;aa = aa;<span class="comment">//将形参aa赋值给对象的成员aa</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>*this可以表示对象。</li>
<li>如果在成员函数的括号后面使用const，那么将不能通过this指针修改成员变量。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>                 <span class="comment">// 超女类CGirl。</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;                    <span class="comment">// 姓名属性。</span></span><br><span class="line">    <span class="type">int</span>         m_yz;                          <span class="comment">// 颜值：1-沉鱼落雁；2-漂亮；3-一般；4-歪瓜裂枣。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个参数的普通构造函数。</span></span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> string &amp;name, <span class="type">int</span> yz)  { m_name = name; m_yz = yz;  }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 超女自我介绍的方法。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span>  </span>{ cout &lt;&lt; <span class="string">"我是："</span> &lt;&lt; m_name &lt;&lt; <span class="string">"，最漂亮的超女。"</span>&lt;&lt; endl; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超女颜值pk的方法。</span></span><br><span class="line">    <span class="function"><span class="type">const</span> CGirl&amp; <span class="title">pk</span><span class="params">(<span class="type">const</span> CGirl&amp; g)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span> (g.m_yz &lt; m_yz) <span class="keyword">return</span> g;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 比较五个超女的颜值，然后由更漂亮的超女作自我介绍。</span></span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">"西施"</span>,<span class="number">5</span>)</span>, <span class="title">g2</span><span class="params">(<span class="string">"西瓜"</span>,<span class="number">3</span>)</span>, <span class="title">g3</span><span class="params">(<span class="string">"冰冰"</span>, <span class="number">4</span>)</span>, <span class="title">g4</span><span class="params">(<span class="string">"幂幂"</span>, <span class="number">5</span>)</span>, <span class="title">g5</span><span class="params">(<span class="string">"金莲"</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="type">const</span> CGirl&amp; g = g1.<span class="built_in">pk</span>(g2).<span class="built_in">pk</span>(g3).<span class="built_in">pk</span>(g4).<span class="built_in">pk</span>(g5);</span><br><span class="line">    g.<span class="built_in">show</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="十一、静态成员">十一、静态成员</h2>
<ul>
<li>类的静态成员包括<strong>静态成员变量</strong>和<strong>静态成员函数</strong>。</li>
<li>用静态成员可以变量实现多个对象之间的数据共享，<strong>比全局变量更安全性</strong>。</li>
<li>用<code>static</code>关键字把类的成员变量声明为静态，表示它在程序中（不仅是对象）是共享的。</li>
<li>静态成员变量不会在创建对象的时候初始化，必须在程序的<strong>全局区</strong>用代码清晰的初始化（用范围解析运算符 ::）。</li>
<li>静态成员使用类名加范围解析运算符 <code>::</code> 就可以访问，不需要创建对象。</li>
<li>如果把类的成员声明为静态的，就可以把它与类的对象独立开来（<strong>静态成员属于类，但不属于对象</strong>）。</li>
<li>静态成员变量在程序中只有一份（<strong>生命周期与程序运行期相同，存放在静态存储区的</strong>），不论是否创建了类的对- 象，也不论创建了多少个类的对象。</li>
<li>在静态成员函数中，只能访问静态成员，不能访问非静态成员。</li>
<li>静态成员函数中<strong>没有this指针</strong>。</li>
<li>在非静态成员函数中，可以访问静态成员。</li>
<li>私有静态成员在类外无法访问。</li>
<li><code>const</code>静态成员变量可以在定义类的时候初始化。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>                 <span class="comment">// 超女类CGirl。</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_age;                        <span class="comment">// 年龄属性。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string      m_name;                    <span class="comment">// 姓名属性。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个参数的普通构造函数。</span></span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> string&amp; name, <span class="type">int</span> age) { m_name = name; m_age = age; }</span><br><span class="line">    <span class="comment">// 显示超女的姓名。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showname</span><span class="params">()</span>  </span>{ cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; endl; }</span><br><span class="line">    <span class="comment">// 显示超女的年龄。</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">showage</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"年龄："</span> &lt;&lt; m_age &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> CGirl::m_age=<span class="number">8</span>;        <span class="comment">// 初始化类的静态成员变量。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">"西施1"</span>, <span class="number">21</span>)</span>, <span class="title">g2</span><span class="params">(<span class="string">"西施2"</span>, <span class="number">22</span>)</span>, <span class="title">g3</span><span class="params">(<span class="string">"西施3"</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    g1.<span class="built_in">showname</span>(); g1.<span class="built_in">showage</span>();</span><br><span class="line">    g2.<span class="built_in">showname</span>(); g2.<span class="built_in">showage</span>();</span><br><span class="line">    g3.<span class="built_in">showname</span>(); g3.<span class="built_in">showage</span>();</span><br><span class="line"></span><br><span class="line">    CGirl::<span class="built_in">showage</span>();</span><br><span class="line">    <span class="comment">// cout &lt;&lt; "CGirl::m_age=" &lt;&lt; CGirl::m_age &lt;&lt; endl;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="十二、简单对象模型">十二、简单对象模型</h2>
<p>在C语言中，数据和处理数据的操作（函数）是分开的。也就是说，C语言本身没有支持数据和函数之间的关联性。<br>
C++用类描述抽象数据类型（abstract data type，ADT），<u>在类中定义了数据和函数，把数据和函数关联起来</u>。<br>
对象中维护了多个<strong>指针表</strong>，表中放了成员与地址的对应关系。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>       <span class="comment">// 超女类CGirl。</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>    m_name[<span class="number">10</span>];              <span class="comment">// 姓名属性。</span></span><br><span class="line">    <span class="type">int</span>      m_age;                   <span class="comment">// 年龄属性。</span></span><br><span class="line">    <span class="comment">// 默认构造函数和析构函数。</span></span><br><span class="line">    <span class="built_in">CGirl</span>() { <span class="built_in">memset</span>(m_name, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_name)); m_age = <span class="number">0</span>;  }</span><br><span class="line">    ~<span class="built_in">CGirl</span>() {  }</span><br><span class="line">    <span class="comment">// 显示超女的姓名。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showname</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; endl; }</span><br><span class="line">    <span class="comment">// 显示超女的年龄。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showage</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"年龄："</span> &lt;&lt; m_age &lt;&lt; endl; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>C++类中有两种数据成员：nonstatic、static，三种函数成员：nonstatic、static、virtual。</p>
<ul>
<li>对象内存的大小包括：1）所有<strong>非静态数据成员</strong>的大小；2）由内存对齐而填补的内存大小；3）为了支持virtual成员而产生的额外负担。</li>
<li><strong>静态成员变量属于类，不计算在对象的大小之内</strong>。</li>
<li>成员函数是分开存储的，不论对象是否存在都占用存储空间，<strong>在内存中只有一个副本</strong>，也<strong>不计算在对象大小之内</strong>。</li>
<li>用空指针可以调用没有用到this指针的非静态成员函数。</li>
<li><strong>对象的地址是第一个非静态成员变量的地址</strong>，如果类中没有非静态成员变量，编译器会隐含的增加一个1字节的占位成员。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>       <span class="comment">// 超女类CGirl。</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>    m_name[<span class="number">3</span>];              <span class="comment">// 姓名属性。</span></span><br><span class="line">    <span class="type">int</span>       m_bh;                        <span class="comment">// 编号属性。</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span>       m_age;                      <span class="comment">// 年龄属性。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数和析构函数。</span></span><br><span class="line">    <span class="built_in">CGirl</span>() { <span class="built_in">memset</span>(m_name, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_name)); m_age = <span class="number">0</span>;  }</span><br><span class="line">    ~<span class="built_in">CGirl</span>() {  }</span><br><span class="line">    <span class="comment">// 显示超女的姓名。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showname</span><span class="params">()</span> </span>{ <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">nullptr</span>) <span class="keyword">return</span>;  cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_name &lt;&lt; endl; }</span><br><span class="line">    <span class="comment">// 显示超女的年龄。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showage</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"年龄："</span> &lt;&lt; m_age &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> CGirl::m_age;</span><br><span class="line"><span class="type">int</span> aaa;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    CGirl g;</span><br><span class="line">    cout &lt;&lt; <span class="string">"对象g占用的内存大小是："</span> &lt;&lt; <span class="built_in">sizeof</span>(g) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"对象g的地址是："</span> &lt;&lt; (<span class="type">void</span>*)&amp;g &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"成员变量m_bh的地址是："</span> &lt;&lt; (<span class="type">void</span>*)&amp;g.m_bh &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"成员变量m_name的地址是："</span> &lt;&lt; (<span class="type">void</span>*)&amp;g.m_name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"成员变量m_age的地址是："</span> &lt;&lt; (<span class="type">void</span> *)&amp;g.m_age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"全局变量aaa的地址是："</span> &lt;&lt; (<span class="type">void</span>*)&amp;aaa &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"成员函数showname的地址是：%p\n"</span>, &amp;CGirl::showname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"成员函数showage的地址是：%p\n"</span>, &amp;CGirl::showage);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"函数func()的地址是：%p\n"</span>, func);</span><br><span class="line"></span><br><span class="line">    CGirl* g1 = <span class="literal">nullptr</span>;</span><br><span class="line">    g1-&gt;<span class="built_in">showname</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="十三、友元">十三、友元</h2>
<p>如果要访问类的私有成员变量，调用类的公有成员函数是唯一的办法，而类的私有成员函数则无法访问。<br>
友元提供了另一访问类的私有成员的方案。友元有三种：</p>
<ul>
<li>友元全局函数。</li>
<li>友元类。</li>
<li>友元成员函数。</li>
</ul>
<ol>
<li>友元全局函数<br>
在<strong>友元全局函数</strong>中，可以访问另一个类的所有成员。</li>
<li>友元类<br>
在<strong>友元类所有成员函数</strong>中，都可以访问另一个类的所有成员。<br>
友元类的注意事项：
<ul>
<li>友元关系<strong>不能被继承</strong>。</li>
<li>友元关系是<strong>单向</strong>的，不具备交换性。</li>
</ul>
</li>
<li>友元成员函数<br>
在<strong>友元成员函数</strong>中，可以访问另一个类的所有成员。<br>
如果要把男朋友类CBoy的某成员函数声明为超女类CGirl的友元，声明和定义的顺序如下：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>;            <span class="comment">// 前置声明。   </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBoy</span> { ...... };      <span class="comment">// CBoy的定义。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span> </span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">CBoy::func</span><span class="params">(CGirls &amp;g)</span></span>;</span><br><span class="line">     ...... </span><br><span class="line">};      <span class="comment">// CGirl的定义。</span></span><br><span class="line">                                      </span><br><span class="line"><span class="comment">// 友元成员函数的定义。               </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CBoy::func</span><span class="params">(CGirl &amp;g)</span> </span>{ ...... }       </span><br></pre></td></tr></tbody></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>       <span class="comment">// 超女类CGirl。</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;   <span class="comment">// 姓名。</span></span><br><span class="line">    <span class="comment">// 默认构造函数。</span></span><br><span class="line">    <span class="built_in">CGirl</span>() { m_name = <span class="string">"西施"</span>;  m_xw = <span class="number">87</span>; }</span><br><span class="line">    <span class="comment">// 显示姓名的成员函数。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showname</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; endl; }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>         m_xw;        <span class="comment">// 胸围。</span></span><br><span class="line">    <span class="comment">// 显示胸围的成员函数。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showxw</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"胸围："</span> &lt;&lt; m_xw &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    CGirl g;</span><br><span class="line">    g.<span class="built_in">showname</span>();</span><br><span class="line">    g.<span class="built_in">showxw</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>       <span class="comment">// 超女类CGirl。</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CBoy</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;   <span class="comment">// 姓名。</span></span><br><span class="line">    <span class="comment">// 默认构造函数。</span></span><br><span class="line">    <span class="built_in">CGirl</span>() { m_name = <span class="string">"西施"</span>;  m_xw = <span class="number">87</span>; }</span><br><span class="line">    <span class="comment">// 显示姓名的成员函数。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showname</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; endl; }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>         m_xw;        <span class="comment">// 胸围。</span></span><br><span class="line">    <span class="comment">// 显示胸围的成员函数。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showxw</span><span class="params">()</span> <span class="type">const</span> </span>{ cout &lt;&lt; <span class="string">"胸围："</span> &lt;&lt; m_xw &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBoy</span>    <span class="comment">// 超女的男朋友类</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> CGirl&amp; g)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"我女朋友的姓名是："</span> &lt;&lt; g.m_name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"我女朋友的胸围是："</span> &lt;&lt; g.m_xw &lt;&lt; endl;</span><br><span class="line">        g.<span class="built_in">showxw</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    CGirl g;</span><br><span class="line">    CBoy b;</span><br><span class="line">    b.<span class="built_in">func</span>(g);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>;      <span class="comment">// 把超女类的声明前置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBoy</span>    <span class="comment">// 超女的男朋友类</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">const</span> CGirl&amp; g)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">const</span> CGirl&amp; g)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>       <span class="comment">// 超女类CGirl。</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">CBoy::func1</span><span class="params">(<span class="type">const</span> CGirl&amp; g)</span></span>;</span><br><span class="line">    <span class="comment">// friend void CBoy::func2(const CGirl&amp; g);</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;   <span class="comment">// 姓名。</span></span><br><span class="line">    <span class="comment">// 默认构造函数。</span></span><br><span class="line">    <span class="built_in">CGirl</span>() { m_name = <span class="string">"西施"</span>;  m_xw = <span class="number">87</span>; }</span><br><span class="line">    <span class="comment">// 显示姓名的成员函数。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showname</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; endl; }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>         m_xw;        <span class="comment">// 胸围。</span></span><br><span class="line">    <span class="comment">// 显示胸围的成员函数。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showxw</span><span class="params">()</span> <span class="type">const</span> </span>{ cout &lt;&lt; <span class="string">"胸围："</span> &lt;&lt; m_xw &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CBoy::func1</span><span class="params">(<span class="type">const</span> CGirl&amp; g)</span> </span>{ cout &lt;&lt; <span class="string">"func1()我女朋友的胸围是："</span> &lt;&lt; g.m_xw &lt;&lt; endl; }</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CBoy::func2</span><span class="params">(<span class="type">const</span> CGirl&amp; g)</span> </span>{ cout &lt;&lt; <span class="string">"func2()我女朋友的姓名是："</span> &lt;&lt; g.m_name &lt;&lt; endl; }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    CGirl g;</span><br><span class="line">    CBoy b;</span><br><span class="line">    b.<span class="built_in">func2</span>(g);</span><br><span class="line">    b.<span class="built_in">func1</span>(g);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
                    </div>
                </div>
            </div>

            <div style="text-align: right;">
                <button type="button" class="read-more">
                    <a href="/2024/01/08/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/">阅读更多</a>
                </button>
            </div>
        
    </div>

    <div class="pagination">
    <div class="paginator">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-caret-right" aria-hidden="true"></i></a>
    </div>
    <div class="paginator-info">
        <span class="gray">39 articles in total</span>
    </div>
</div>
</article>

            <section class="article-bottom flex-between">
                <div class="flex-center">
                    <img src="/imgs/logo.png" class="logo">
                    <span>保持好奇</span>
                </div>
                <div class="flex-center">
                    <a href="mailto:22232025@zju.edu.cn">
                        <span title="envelope">
                            <i class="fa fa-envelope" aria-hidden="true"></i>
                        </span>
                    </a>
                    <a target="_blank" rel="noopener" href="https://github.com/can-dy-jack/hexo-theme-delicate">
                        <span title="github" style="font-size: 18px;">
                            <i class="fa fa-github" aria-hidden="true"></i>
                        </span>
                    </a>
                </div>
            </section>
        </div>
    </main>

    <div class="to-top">
    <a href="javascript: void(0)" onclick="delicate.toTop()">
        <i class="fa fa-chevron-up" aria-hidden="true"></i>
    </a>
</div>

    <footer>
        <div class="footer-info gray">
    <div>
        <span><a target="_blank" rel="noopener" href="https://github.com/can-dy-jack/hexo-theme-delicate">Delicate</a> theme designed with ❤️ by <a target="_blank" rel="noopener" href="https://github.com/can-dy-jack">can-dy-jack</a></span>
    </div>
    <div>
        <span>Copyright Ⓒ 2024. All rights reserved.</span>
    </div>
</div>
    </footer>

    


<script src="/js/index.js"></script>


</body>

</html>